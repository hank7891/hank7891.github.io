{"pages":[],"posts":[{"title":"GIT 還原單一檔案","text":"GIT 如何還原已修改檔案。 GIT 如何將檔案還原至 commit 前版本。 GIT 如何將檔案還原至指定版本。 首先，讓我們看一下 LOG 紀錄。 1$ git log 直接還原已修改檔案直接還原即可，以下兩種語法效果相同。 121. $ git checkout &lt;file&gt;2. $ git checkout -- &lt;file&gt; 還原已 commmit 檔案對於已經 commit 上版控(尚未 push)，用以下步驟還原。 先用 reset 解除 commit 操作。 1$ git reset HEAD^ 如圖中，測試 COMMIT 版本 1 的紀錄會被移除。並保留其修改內容。若是對應檔案有在做修改，會以後續修改版本為主。 再用 checout 還原更改檔案。 1$ git checkout &lt;file&gt; 還原檔案至版控上指定紀錄版本可由圖片中看到各版本的 commit Hash。使用以下語法還原至對應版本。 1$ git checkout &lt;commit Hash&gt; &lt;file&gt; 小知識: Hash 只要取前四碼即可。","link":"/2021/06/12/GIT%E9%82%84%E5%8E%9F%E5%96%AE%E4%B8%80%E6%AA%94%E6%A1%88/"},{"title":"HTML JS 動態顯示 input file 選取內容","text":"使用 HTML 取得本地檔案1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; File API 可以從 File 物件中讀取 FileList ，FileList 內包含使用者所選取的檔案。如果使用者只選擇一個檔案，那麼我們只需要考慮第一個檔案物件。 使用 DOM 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = document.getElementById('testFile').files[0]; 使用 JQUERY 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = $('#testFile').get(0).files[0]; 使用 change event 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; onchange=&quot;selectFile(this.files)&quot; /&gt; JS: 123function selectFile(files) { var file = files[0];} 獲得選取的檔案資訊上述的例子顯示獲取在檔案清單裡所有檔案物件的方法。File 提供三個包含檔案重要訊息的屬性。 name: 唯讀的檔案名稱，並未包含檔案路徑。 size: 為 64 位元的整數，用以表示檔案的 byte 的長度。 type: 為唯讀字串。表示檔案的 MIME-type 。若是無法取得檔案的 Mime-type ，則其值會是一個空字串 “”。 使用 FileReader 讀取文件內容讀取文字HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectTextFile(this.files)&quot; /&gt;&lt;p id=&quot;showText&quot;&gt;&lt;/p&gt; JS: 12345678910111213function selectTextFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showText').src = this.result; }; reader.readAsText(file);} 當然也可以讀取圖片HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectImgFile(this.files)&quot; /&gt;&lt;img id=&quot;showImg&quot;&gt;&lt;/img&gt; JS: 12345678910111213function selectImgFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showImg').src = this.result; }; reader.readAsDataURL(file);} Code Demo","link":"/2020/08/17/HTML-JS-%E5%8B%95%E6%85%8B%E9%A1%AF%E7%A4%BA-input-file-%E9%81%B8%E5%8F%96%E5%85%A7%E5%AE%B9/"},{"title":"Hexo","text":"操作指令12# 開啟服務hexo server 12# 同步指令hexo d -g 細節待補","link":"/2019/11/29/Hexo/"},{"title":"GIT 查看&#x2F;匯出差異檔案","text":"查看指定 commit 修改過檔案差異。 匯出指定 commit 修改過檔案差異 Diff 比對差異檔案1$ git diff 說明: 比對當下**未進暫存區(Add)**所有檔案區別。 1$ git diff --cached 說明: 比對當下**已進暫存區(Add)**所有檔案區別。 1$ git diff &lt;filename&gt; 說明: 比對當下未進暫存區(Add)單一檔案區別。 想一想: 那已進暫存區(Add)單一檔案區別呢？ 1$ git diff &lt;commit-hash&gt; 說明: 比對指定 commit 與 HEAD 檔案區別 1$ git diff &lt;old commit-hash&gt; &lt;new commit-hash&gt; 說明：比對兩個 commit 之間的差異． 比較常用的指令集1234567891011$ git diff HEAD^ HEAD # 比較最新版與最新版前一次版本的差異$ git diff ---stat # 檢視更新的簡略統計資訊。$ git diff --name-only # 在更新的訊息後方顯示更動的檔案列表。$ git diff --name-status # 顯示新增、更動、刪除的檔案列表。$ git diff --diff-filter= [(A|C|D|M|R|T)…​[*]]] # 配合檔案狀態來篩選顯示檔案列表。# A = Added# C = Copied# M = Modified# R = Renamed# T = Changed# D = Delete 讓我們產出差異的檔案清單 1$ git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD diff-tree: 比較兩個 commit 之間的差異。 -r: 列出完整路徑。 –name-only: 不輸出 commit hash –diff-filter=ACMRT: 列出指定類型檔案。 HEAD: 當下版本，可改為任一或多個 commit hash 將結果輸出為 txt 檔1$ git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD &gt; test.txt 匯出差異檔案(含完整路徑)1$ git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD) 注意: 若沒加 $() 內部篩選，會打包整個專案。 小知識 commid hash 只要取前四碼就可以了。 git archive 一定要在版控系統根目錄執行才有作用。","link":"/2021/08/11/GIT%E6%9F%A5%E7%9C%8B:%E5%8C%AF%E5%87%BA%E5%B7%AE%E7%95%B0%E6%AA%94%E6%A1%88/"},{"title":"Interface","text":"Interface 又稱 介面 接口 契約 介面本身是抽象的。指一系列的 Public 屬性或函式。所以你的物件，即便沒有實作任何介面他本身也是一個介面。它提供的介面就是自己所有 Public 的屬性跟函式。 介面可以確保依賴物件提供你想要的功能。 每個物件都是實作介面。 創造物件實作基礎介面，你的物件就可以執行語言的基礎函式 ex: foreach。 舉例: PHP 中的 array 也是實作幾個陣列功能會用到的 interface 還記得一個物件可以實作多個介面嗎？這裡會牽扯到兩個物件的耦合程度。假設你的函式宣告參數的型別是宣告成某個介面。那你在函式裡面只會拿到介面的 Public 屬性跟函式。但是如果你把參數的型別直接宣告成某個物件，在函式裡面就會拿到物件的所有 Public 屬性跟介面。 如果你的函式只需要其中一個介面提供的功能，那就在把參數的型別指定為介面就好。否則你會依賴整個物件。 結論你會發現整個語言都是照著介面在開發。所以有人常說 programin to a interface。介面只是定義一個抽象的概念，至於要實作成什麼樣子，是需要按照需求來決定。 重點是 interface 或抽象類別，都是向上層程式碼保證他們能提供指定的功能。 – 小知識: C＃ 跟 Java 一定會宣告參數的型別。這個叫做 Type hint，如果丟進去的參數不符合型別，編譯時就報錯。所以被叫做強型別語言。 PHP 跟 JS 沒有強迫一定要有 Type hint。稱作弱型別語言。","link":"/2019/11/26/Interface/"},{"title":"JavaScript基礎篇[1] 變數與資料型別","text":"JavaScript 基礎 – 變數與資料型別。 變數可以將變數想像為一個盒子，是用來存放資料的。 在 JavaScript 中的變數宣告是有規則的，開頭必須是英文字母、底線(_)或錢字號($)，後面可以接著英文字母、底線(_)或錢字號($)以及數字。變數名稱不可以是保留字(Reserved Words) 與關鍵字(keyword)。 JavaScript 是有區分大小寫的，變數 apple 與 Apple 將會被視為不同的兩個變數。且 1.3 版之後支援 Unicode。代表著你可以用中文來當變數名稱。 但還是避免使用非英文字母來做變數名稱命名，用中文編碼的話，其他語系系統開啟可能會造成亂碼的情況。 變數在使用前，可以透過 var 來進行宣告的動作。在 ES6 之後多了 let 與 const 兩種。由於 JavaScript 是個 弱型別[註1] 的語言，變數本身無需宣告型別，型別的資訊只在值或物件本身。 12345// 透過 var 宣告變數 apple 但沒賦予其值，此時 apple 的內容為 undefined。var apple;// 透過 var 宣告變數 apple 且賦予其值，此時 apple 的內容為 'apple'。var apple = 'apple'; 若沒宣告變數就要使用的情況下，會出現 ReferenceError。 如下: 1console.log(hello); 或許你會發現，即便沒有用 var 進行變數宣告，仍可以定義變數並給予值。但強烈不建議這麼做。因為，沒有使用 var 宣告的變數，全都會變成全域變數。 全域變數 後續再做解說。 12apple = 'apple';console.log(apple); // 沒錯，就是 'apple'。 註1: 程式語言中，是有型別系統(type system)的。區分為型別、弱型別。強型別語言在定義變數時就必須給予變數指定型別，若這個變數做了錯誤型別運算，則會出現錯誤。弱型別語言則相反，雖然多了許多方便性，但要注意型別轉換時可能產生的非預期錯誤。 資料型別 變數沒有型別，值才有。 由於 JavaScript 是個弱型別的程式語言，嚴格來說，變數本身其實不帶有資料型別的資訊，其中的值或物件才有。 JavaScript 的型別主要可分為原始型別(Primitives)與物件型別(Object)。 原始型別包含了 string、number、boolean、null、undefined。而在 ES6 中多了 Symbol。 12345typeof true; // 'boolean'typeof 'apple'; // 'string'typeof 123; // 'number'typeof { }; // 'object'typeof [ ]; // 'object' string 字串字串需用單引號 ' '或雙引號 &quot; &quot;包住，兩者不可混用，意思是誰開頭就要誰結尾。 單引號與雙引號的使用在 JavaScript 沒有什麼差異，依習慣使用即可。 12var str = '我是字串';var str2 = &quot;我也是字串&quot;; 若引號不成雙對的話會出狀況，如: 12var str = 'Let's go!'; // Errorvar str = &quot;Let's go!&quot;; // OK 如果真的非用單引號不可，則可用 \\(跳脫字元 escape character)處理: 1var str = 'Let\\'s go!'; // OK 組合字串用 +: 1var str = 'Hello, ' + 'word.'; 字串太長需換行銜接可用 \\: 123var str = '這是第一行 \\這是第二行 \\這是第三行'; 注意: \\ 後面不能有東西呦，包含空白。 number 數字JavaScript 僅有的一種數值的型別，不管整數或小數點都是。 12var num = 1;var num = 1.2; 特殊的數字 Infinity (無限大)、-Infinity (負無限大)，以及 NaN。備註: NaN 不是數值。 正數除以 0 會得到 Infinity (無限大)，負數除以 0 會得到 -Infinity (負無限大)。 12var num = 1 / 0; // Infinityvar num = -1 / 0; // -Infinity 那 0/0 呢？ 結果是 NaN。甚至是 Infinity / Infinity 或 -Infinity / -Infinity 也會都得到 NaN。NaN 是個有趣的存在，字面上的意思是 Not a Number。但用 typeof 來判斷，他又告訴你它是 number。 1console.log(typeof NaN); // number NaN 無法做任何數字的運算，結果都會是 NaN。也就是說 NaN 不屬於任何數字，甚至是自己。 1NaN === NaN; // false 所以我們需要 isNaN 函示來檢查它: 1234isNaN(NaN); // trueisNaN(123); // falseisNaN(&quot;123&quot;); // false, 因為字串 &quot;123&quot; 可以透過隱含的 Number() 轉型成數字isNaN(&quot;NaN&quot;); // true, 因為字串 &quot;NaN&quot; 無法轉成數字 順帶一提，JavaScript 的 number 也是基於 IEEE 754 來實作。所以當你執行 0.1 + 0.2 == 0.3 時。 為什麼呢！？這是因為… 自己看 Why 0.1 + 0.2 !== 0.3 不僅是 JavaScript 會產生這種問題，只要是採用 IEEE 754 的浮點數編碼方式來表示浮點數時，全都會產生這類問題。 boolean 布林值 JavaScript 中，所有的東西都可以轉換為 boolean。 boolean 就簡單多了，其值只有兩種: true、false。是由發明的科學家 George Boole 命名。 123var a = true;var b = false;var c = (2 &gt; 1); // true null &amp; undefined若使用 Boolean() 將 null 與 undefined 轉換為布林值，結果都會是 false。但兩者間仍有意義上的差別，故將它們放在一起講。 兩者的共通點是都只有一種值，null 僅有 null，undefined 僅有 undefined。 12var a; // undefined, 宣告卻未給值。var b = null; // null, 明確給予變數 null。 undefined 代表的是**(此變數) 還沒有給值，所以不知道是什麼**。 null 代表的是此變數可能曾經有值)，但現在沒有值。 也可以使用 Number() 強制轉換為數字來看出什麼。 12Number( null ); // 0Number( undefined ); // NaN 還有一點有趣的事，在非全域作用範圍下 undefined 允許被當成是變數使用。 12345(function() { var undefined = 'apple'; console.log(undefined); // apple console.log(typeof undefined); // string})() 甚至是被當成參數來用: 1234(function(undefined) { console.log(undefined); // apple console.log(typeof undefined); // string})('apple') 我看還是別這樣惡搞你的程式了吧。搞同事的就好！ 基礎篇[2]: —&gt;&gt;&gt;","link":"/2020/12/06/JavaScript-%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5/"},{"title":"Javascript FormData 應用","text":"Javascript FormData 應用。Javascript 傳送 File 檔案。 What is FormData? 所有向伺服器提交的 HTTP 資料，都是一個表單 FromData 是一種容器，用來模擬表單，向伺服器提交資料，最大的優點是可以傳送二進制文件（File、Blob），簡單來說它就是一個 Object。 建立方式有兩種，第一種是由 HTML 去建立: 123456789&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;/form&gt;&lt;script&gt; var fd = new FormData(document.getElementById(&quot;Form&quot;));&lt;/script&gt; 注意: 若此處使用 JQuery 去取得 form 表單，會出現錯誤 Uncaught TypeError: Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'. 這是因為 JQuery 取得的是一個數組，而不是 dom 節點，可用以下方式轉換為節點。 12345// $('#Form').eq(0)[0];&lt;script&gt; var fd = new FormData($('#Form').eq(0)[0]);&lt;/script&gt; 第二種是透過 Javascript 去建立。 12var fd = new FormData();fd.append('name', 'YoYo'); 實際應用若是要使用 append 方式來放置 file 資料時，可以這麼做。而後端取得方式與 form 表單直接送出無異。 ex: $_FILES(PHP) 1234567891011121314151617181920212223242526272829&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot; &gt;test&lt;/button&gt;&lt;/form&gt;&lt;script&gt;$('#btn').on('click', function () { // 資料建置 var file_data = $('#file').prop('files')[0]; var fd = new FormData(); fd.append('file', file_data); fd.append('name', $('#name').val()); // 傳送請求 $.ajax({ type: &quot;POST&quot;, contentType: false, processData: false, url: url, data: fd, success: function (data) { // TODO } });});&lt;/script&gt; 觀看資料直接使用 console.log 去呈現 FormData 是會看不到東西的，我們可以用 forEach 將資料放到另一個 Obj 再做呈現。 1234567891011121314151617181920212223&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot; &gt;test&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $('#btn').on('click', function () { // 資料建置 var file_data = $('#file').prop('files')[0]; var fd = new FormData(); fd.append('file', file_data); fd.append('name', $('#name').val()); // 資料輸出 var object = {}; fd.forEach((value, key) =&gt; { object[key] = value; }); console.log(object) });&lt;/script&gt;","link":"/2021/04/14/Javascript%20FormData%20%E6%87%89%E7%94%A8/"},{"title":"Linux 修改檔案名稱","text":"Linux 單次修改檔案名稱。 Linux 批次修改檔案名稱。 單檔案命名用 mv指令 mv，其實最主要的功能是拿來搬移檔案，不過在搬移的時候能夠進行重新指定檔名，所以就被順理成章的成為我們重新命名的指令了。 12# 指令 舊檔案 新檔案$ mv old_file new_file 多檔案命名用 renamerename 指令可以做大量的檔案更名，它使用 perl 的正規表式法來訂定格式，也稱為 perl-rename，因此 prename 與 rename 兩個指令是相同的。不過在 Ubuntu 20.04 之後，rename 指令已經沒有內建了，必須自行安裝。 在 Ubuntu 20.04 內建有另一款叫 rename.ul 的更名指令，兩個指令的使用方法並不相同，這邊先以 perl rename 來試範一些我常用的更名方法。 安裝Ubuntu 20.04 安裝 rename（Ubuntu 18.04 以前已內建） 123$ sudo apt install rename# or$ brew install rename 基本用法1$ rename 's/原字串/新字串/' 要改的檔案 -n：僅列出更名後的結果，不會真的進行更名，建議更名前一定要檢查。 -d：不對資料夾做更名，僅針對目標路徑下的檔案。 基本檔名更改將 A1、A2、A3 改為 B1、B2、B3 12# 所有檔案$ rename 's/A/B/' * 若碰到需要修改特殊字元，需再前面加上反斜線(\\)。 在開頭/結尾插入文字將 A1、A2、A3 改為 ZA1、ZA2、ZA3 12# 所有檔案$ rename 's/^/Z/' * 將 A1、A2、A3 改為 A10、A20、A30 12# 所有檔案$ rename 's/$/Z/' * 批次更改副檔名將 .html 改成 .phtml 12# 所有 .html 結尾的檔案$ rename 's/\\.html$/\\.phtml/' *.html .的前面需加上跳脫符號\\。 原檔名加上$是因為要改的是結尾的副檔名，沒有加$的話，如果原檔名中也有 html 的字串，會被一併更改。 大小寫轉換大寫轉小寫 1$ rename 'y/A-Z/a-z/' * 小寫轉大寫 1$ rename 'y/a-z/A-Z/' *","link":"/2021/07/01/Linux%20%E4%BF%AE%E6%94%B9%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1/"},{"title":"Linux 排程設定(crontab)","text":"linux 排程設定。 linux crontab 設定。 linux 自動工作設定 crontab 設定。 夠了哦！！… 查看與編輯查看自己 crontab 1crontab -l 查看指定使用者的 crontab 1sudo crontab -u username -l 編輯自己的 crontab 1crontab -e 編輯指定使用者的 crontab 1sudo crontab -u username -e 刪除所有 crontab – 注意: 是所有!!! 1crontab -r 設定在 crontab 設定中，每一行設定就代表一個定期排程。 基本設定格式如下: 1MIN HOUR DOM MON DOW CMD 欄位 說明 解說 MIN 分鐘 0 - 59。 HOUR 小時 0 - 23。 DOM 日 1 - 31。 MON 月 1 - 12，可用英文縮寫 Ex: Jan。 DOW 星期 0 - 7，0 與 7 的是星期日。也可用英文縮寫 Ex: Sun。 CMD 執行指令 任何可執行的程式或指令稿。 特殊符號 字元 說明 *(星號) 代表接受任意時刻。 若在月份那一欄填入星號，則代表每一月份皆會執行指令。 ,(逗號) 代表分隔時段。 如果要下達的工作是 3:00 與 6:00 時，就會是： 0 3,6 * * * CMD -(減號) 代表一段時間範圍內。 8 點到 12 點之間的每小時的 20 分都進行一項工作：20 8-12 * * * CMD /n(斜線) n 代表數字，亦即是『每隔 n 單位間隔』的意思，例如每五分鐘進行一次，則：*/5 * * * * CMD 開始設定由於需要設定的內容很多又不方便記憶，所以可以將下列註解貼在開頭。 1234567# ┌───────────── 分鐘 (0 - 59)# │ ┌─────────── 小時 (0 - 23)# │ │ ┌───────── 日 (1 - 31)# │ │ │ ┌─────── 月 (1 - 12)# │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日)# │ │ │ │ │# * * * * * command 以下是一些基本的範例，指令為寫入觸發時間。 注意: 確認執行路徑是否可行，可先將 cmd 指令拿去執行看是否可行。 12# 輸出觸發時間至指定位置date &gt;&gt; ~/text.txt 12345678# 每五分鐘執行一次*/5 * * * * date &gt;&gt; ~/text.txt# 每日早上 8 點到 12 點，整點執行0 8-12 * * * date &gt;&gt; ~/text.txt# 每月 1 日 、15 日、29 日 凌晨五點各執行一次0 5 1,15,29 * * date &gt;&gt; ~/text.txt 設定好後儲存，即可生效！ 實用工具 Crontab Guru，能夠幫你轉換為人類可讀時間。","link":"/2021/03/12/Linux%20%E6%8E%92%E7%A8%8B%E8%A8%AD%E5%AE%9A(crontab)/"},{"title":"Mac建置自製Apache教學","text":"在 Mac 上建立自製 Apache 環境筆者心情小語…當你開心的遛個狗，哼哼小曲沒事想說更新一下心愛的 MAC 突然 Apache 開發環境就被 MAC OS 給狹持了(設定重置)!! 所以說 Apache 開發環境必須獨立! 特別感謝: 給力小夥伴指導我許多 LINUX 與 APACHE 相關設定及觀念。 為什麼要自製 Apache 環境MAC OS 更新版本有時都會突然的重置原生 Apache 設定。 特別是此次 OS 10.14，連 PHP 外部建置環境都給禁止了!! 若您是使用套件架設環境(MAMP、LAMP、XMAPP等…)，那您可能不會有太大的感悟。 但若是您用的是 MAC 提供的原生 Apache，那您可能連做個系統小更新都要小心翼翼的。 此處筆者用 HomeBrew 進行自製 Apache 環境建置。 需求 Mac OS(Linux) 系統電腦一台。 HomeBrew 開始建置吧 關閉 Mac OS 原生的 Apache 並防止他自行啟動 12345// 關閉 apache$ sudo apachectl stop// 禁止 apache httpd 自動啟動$ sudo launchctl unload /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/null 使用 HomeBrew 安裝 apache 1$ brew install httpd 通過指令檢查 apache 安裝，路徑應該被更改為 /usr/local/bin/apachectl 1$ which apachectl 確認啟用指令被改寫後，重啟 apache 1$ sudo apachectl -k start 設置預設啟用程序 1$ sudo brew services start httpd 設置 apache 基礎設定 brew 建置的 Apache 位置為: /usr/local/etc/httpd 編輯 httpd.conf 修改以下項目: Listen 80 ServerName localhost DocumentRoot &quot;/usr/local/var/www&quot; 開啟 rewrite_module (移掉 #): LoadModule rewrite_module lib/httpd/modules/mod_rewrite.so 至此， apache 應已建置完成並啟用。 連結網站吧！ 後話若您是剛開始進行網站架設，那後續 PHP 安裝可透過 brew 安裝。也可透過 Liip 進行後續環境建置。 請繼續往下走。 若您與筆者一樣是遭逢巨變而需要重新建置新環境。那後續設定僅需由 Mac Apache 那邊移植設定檔即可(注意設定檔不可直接使用，許多路徑都不同了)。 Liip 部分 筆者是自行移植載入檔案(/etc/apache2/other)，並於 httpd.conf 下自行添加 Include /usr/local/etc/httpd/other/*.conf。 HomeBrew 建置 PHP 環境待補 Liip 建置 PHP 環境待補 小知識: Mac OS 是使用 plist 文件設置程序隨機啟動。 plist 文件分佈在: /System/Library/LaunchDaemons/ 中，其中指令 apache 及 httpd 相關配置文件為 org.apache.httpd.plist。 使用 brew 不需 root 身份，若以 root 身份執行會被停止且警告。","link":"/2019/11/29/Mac%E5%BB%BA%E7%BD%AE%E8%87%AA%E8%A3%BDApache%E6%95%99%E5%AD%B8/"},{"title":"Mysql 帳號管理","text":"Mysql 帳號權限管理Mysql 帳號新增Mysql 帳號修改Mysql 外部連線 User 權限觀看1234# 查看登入 User 權限，以下語法效果皆相同。SHOW GRANTS;SHOW GRANTS FOR CURRENT_USER;SHOW GRANTS FOR CURRENT_USER(); 12# Show 出系統所有的 UserSELECT User,Host FROM mysql.user; 12# 查看指定帳號SHOW GRANTS FOR root@localhost; 帳號管理123# 新增帳號 (帳號) (IP) (密碼) CREATE USER 'test'@'localhost' IDENTIFIED BY '1234'; 此帳號設定 IP 的 localhost 代表只能在本機登入，若是想開放遠端登入，須將 localhost 修改為對應 IP 或是不限制的話可以設定 **%**。 12# 密碼修改ALTER USER 'test'@'localhost' IDENTIFIED BY '2222'; 讀者們或許會在別的地方看到 set password、update mysql.user set password 的更新密碼方式，上述方式於 Mysql 5.7 版後已不適用。 12# 刪除帳號DROP user test@localhost ; 編輯權限1234567# 調整對應帳號權限 (操作權限) (帳號) (密碼)GRANT ALL ON *.* TO 'test'@'localhost' IDENTIFIED BY '2222' WITH GRANT OPTION; (資料庫).(資料表) # 重新整理FLUSH PRIVILEGES; 操作權限: create,alter,drop,select,insert,update,delete(全部都要的話可用 ALL)。 資料庫/資料表: 可針對指定資料庫及資料表做操作(全部都要的話用 *)。 注意修改權限以後 一定要重新整理服務，或者重啟服務，重新整理服務。 12# 重新整理FLUSH PRIVILEGES;","link":"/2021/05/30/Mysql%20%E5%B8%B3%E8%99%9F%E7%AE%A1%E7%90%86/"},{"title":"PHP Closure(閉包、匿名函式)","text":"還不知道 PHP 有 Closure? 那你真的落伍了！ What is Closure?Closure: 用於表示匿名函式的 Class。 閉包減少了命名空間的混亂。也讓使用對象之間減少了相依性。 PHP5.3 開始支援匿名函式，讓一些需要彈性的場合更方便。 建立匿名函式注意: 賦予變數匿名函示，結尾大括號需要加結尾符號 ;。 12345$wellcome = function () { echo 'Hi, wellcome to my Home ';};$wellcome(); 我們可以透過 use 的宣告語法賦予匿名函式變數。注意: PHP 7.1 起，不能傳入此類變數：superglobals、 $this 或者和參數重名。 123456$houseCategory = 'villa';$wellcome = function () use ($houseCategory) { echo 'Hi, wellcome to my ' . $houseCategory . '.';};$wellcome(); 讓我們添加函式的指定參數 123456$houseCategory = 'villa';$wellcome = function ($name) use ($houseCategory) { echo 'Hi ' . $name . ', wellcome to my ' . $houseCategory . '.';};$wellcome('YoYo'); 會使用了之後，我們馬上用遞迴特性寫一個從 1 加總到指定數字的閉包吧。 123456789$fib = function ($n) use (&amp;$fib) { if ($n == 0) { return 0; } return $n + $fib($n - 1);};echo $fib(10); 小分享筆者很常在 某段邏輯前後的行為 需要被重複使用時，使用閉包。例如 sql 的 Transaction。此處程式碼為 Demo 用，無法直接執行。 12345678910111213141516171819202122232425262728293031323334353637/** * sqlTransaction * * @param \\Closure $closure * * @return mixed * @throws Exception */public function sqlTransaction(\\Closure $closure){ $db = \\Zend_Db_Table::getDefaultAdapter(); try{ $db-&gt;beginTransaction(); $re = $closure(); $db-&gt;commit(); return $re; }catch (Exception $e){ $db-&gt;rollBack(); throw new Exception($e-&gt;getMessage()); }}public function saveData(){ $model = $this-&gt;_model; $this-&gt;sqlTransaction(function () use ($data, $model) { // TODO 邏輯檢查 $model-&gt;update(data); // TODO 更新後行為 });} 小知識 閉包可利用遞迴特性，取代 foreach 效果。 閉包可用於邏輯處理中段需要客製化邏輯時。 再叫現代化的 PHP 框架(如 Laravel)中，閉包已經是被大量使用的技術。 有興趣可自行去翻閱 Laravel 原始碼。 現在，你學會了嗎！？","link":"/2020/10/25/PHP-Closure-%E9%96%89%E5%8C%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E5%BC%8F/"},{"title":"PHP Traits","text":"What is Traits?PHP 僅支援單一繼承: 子類別只能繼承單一物件。 若是一個類需要繼承多種行為怎麼辦呢？ Traits 解決了這個問題。 Traits 就是解決在單線繼承的限制下，讓程式碼能夠重複使用。並降低複雜度。 Traits 用於聲明可以在多個 class 中使用的屬性(property)/函式(function)，可以是抽象或是任何可視性(public、protect 、private)，甚至是靜態(abstract)屬性。 如何使用建立語法 1234trait TraitName { // some code...} 使用語法 1234class newClass { use TraitName;} Example123456789101112131415trait message{ function msg() { echo 'Welcome to my home.'; }}class Welcome{ use message;}$welcome = new Welcome();$welcome-&gt;msg(); 可以同時使用多個 12345678910111213141516171819202122232425trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msgQuestion() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion;}$welcome = new Welcome();$welcome-&gt;msg();echo '&lt;br/&gt;';$welcome-&gt;msgQuestion(); 若是名稱重複了呢？函式名稱重複是會造成錯誤的。 Fatal error: Trait method msg has not been applied, because there are collisions with other trait methods on... 需要在使用時就指定要用哪一個的方法。insteadof: 宣告前者為主要使用，要是有多個要全部涵蓋進去哦。 123456789101112131415161718192021222324252627282930313233trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}trait messageC{ function msg() { echo 'C'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion, messageC; }}$welcome = new Welcome();$welcome-&gt;msg(); 那被替代掉的函式都不能用了嗎？as: 替方法進行別名。 1234567891011121314151617181920212223242526trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion; messageQuestion::msg as msgQuestion; }}$welcome = new Welcome();$welcome-&gt;msgQuestion(); 小提醒: 就算有使用 as 進行別名，還是需要先使用 insteadof 解重名哦。","link":"/2020/09/23/PHP-Traits/"},{"title":"PHP 資訊安全 - 資料消毒","text":"荀子-性惡篇第二十三: 人之性惡，其善者僞也。 永遠不要相信任何來源不明的資料 不可信資料來源只要不是系統產出組合之資料，皆不可信。 如下: 12345678910$_GET$_POST$_REQUEST$_COOKIE$argvphp://stdinfile_get_contents()遠端資料庫遠端 API來自客戶端的資料 只要是外部來源資料都有可能是攻擊的源頭(XSS、CSRF等…) 怎麼說呢？您的網站允許使用 HTML 下評論，那將有可能受到 &lt;script&gt; 隱碼攻擊。 12345&lt;p&gt;This is good!!!&lt;/p&gt;&lt;script&gt;window.location.href='https://hank7891.github.io/';&lt;/script&gt; 您的登入帳號密碼被如此輸入，即會遭受 SQL Injection。 1234567891011account: ' OR 1=1 #password: 1234$account = $_GET['account']; // '' OR 1=1 #$password = $_GET['password'];$query = &quot;SELECT * FROM user WHERE account = '$account' AND password = '$password'&quot;;產生指令: SELECT * FROM user WHERE account = '' OR 1=1 #AND password = '1234'; 如此一來是不是令您毛骨悚然呢？ 所以呢？想要開發安全的 Web 應用程式，最重要的是正確掌握資料的用途狀態。 一般正規化消毒→一般處理用資料 例如：trim、magicquotesgpc、NUL、強制轉型、大小寫轉換、值域範圍檢查、白名單檢查、RegExp規則檢查 HTML輸出用消毒→HTML輸出用資料 例如：htmlspecialchars, strip_tags, htmlentities SQL輸出用消毒→SQL輸出用資料 例如：mysqlrealescape_string, addslashes – 最重要的是，這些用途的資料，應明確加以區別，不要混淆使用，一定要明確配合用途進行轉換。 所有資料的交換，都應使用一般處理用資料來進行，再依資料用途進行消毒，避免混用而造成遺忘或重複消毒。","link":"/2020/11/27/PHP-%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8-%E8%B3%87%E6%96%99%E6%B6%88%E6%AF%92/"},{"title":"PHP 輸出 Log 檔案","text":"用於輸出指定 PHP 檔案資訊。 廢話不多說，直接 Demo123456789101112131415161718192021222324//設定路徑目錄資訊$years = date('Y-m');$url = './log/' . $years . '/log.txt';//取出目錄路徑中目錄(不包括後面的檔案)$dir_name = dirname($url);//如果目錄不存在就建立if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true);}// 寫入資訊$msg = date('Y-m-d H:i:s');//開啟檔案資源通道，不存在則自動建立$fp = fopen($url,&quot;a&quot;);//寫入檔案fwrite($fp,var_export($msg,true).&quot;\\r\\n&quot;);//關閉資源通道fclose($fp);","link":"/2021/03/03/PHP%E8%BC%B8%E5%87%BALog%E6%AA%94%E6%A1%88/"},{"title":"Shell Script - 基礎","text":"將指令寫成檔案，即可讓乏味的重複性工作變得輕鬆。 將命令 Kernel 做事的指令寫成一個檔案，就叫做 Shell Script。 介紹Shell 是一種讓使用者可以和作業系統 Kernel（核心用來控制 CPU、記憶體、硬碟等硬體）互動溝通的橋樑。Shell Script 主要是使用在 Linux 和 MacOS 等 Unix-like 作業系統的自動化操作指令的程式語言。 Hello World建立 .sh 為副檔名的檔案，並賦予其執行權限。 12345678910# 建造檔案touch demo.sh# 賦予權限chmod -x demo.sh# 查看權限ls -l demo.sh# -rwxr-xr-x 實作 Hello World！ 將以下指令寫入指令檔。 1234# 宣告使用 /bin/bash#!/bin/bashecho &quot;Hello World.&quot;; 執行指令檔案 1./demo.sh 恭喜你已完成第一隻 Shell Script！ 變數定義變數時，開頭不用給予 $ 符號但使用變數時就需加上 $。並且注意 = 前後不能有空白。 1234567#!/bin/bashval=Hello Word.;val2=$val;echo $val; # 輸出結果: Hello World.echo $val2; # 輸出結果: Hello World. 雙引號 &quot;&quot; 內容中的特殊字元不會被忽略，而單引號 '' 中的所有特殊字元將被忽略。也可使用 \\ 跳脫符號將之後的一個字元將被視為普通字串。 1234567#!/bin/bashval=&quot;Hello World.&quot;;echo '$val'; # 輸出結果: $valecho &quot;$val&quot;; # 輸出結果: Hello World.echo &quot;\\$val&quot;; # 輸出結果: $val 也可使用花括弧${}來將變數包起來，可以了解變數的使用範圍。 12345#!/bin/bashval=&quot;Hello World.&quot;;echo ${$val}; # 輸出結果: Hello World. 運算運算符號需用 (()) 或 $(()) 包起來，前者在於在於會將計算結果回傳至原變數中(注意放入多個變數則不會運作)**，後者則是將計算結果回傳至指定變數中(可放置多個變數)**。 1234567891011#!/bin/bashval=1;val1=9;((val++)) # 此時 val = 2，注意不用加結尾符號val2=$((val*val1)); # 2 * 9 = 18echo $val; # 輸出 2echo $val1; # 輸出 9echo $val2; # 輸出 18 判斷式Shell 的判斷式有個潮爆了的特型，那就是結尾都是開頭的顛倒！Ex: if...fi、case ... esac… 先了解比對語法: 語法 代表意義 -eq/== 兩數值相等 (equal) -ne/!= 兩數值不等 (not equal) -gt n1 大於 n2 (greater than) -lt n1 小於 n2 (less than) -ge n1 大於等於 n2 (greater than or equal) -le n1 小於等於 n2 (less than or equal) if…fi判斷條件放置於[]中，前後須留白。 1234567891011121314#!/bin/bashx=1;y=2;if [ $x == $y ]; then echo 'x = y';elif [ $x -gt $y ]; then echo 'x &gt; y';elif [ $x -lt $y ]; then echo 'x &lt; y';else echo '有本事把我用出來';fi case…esac123456789101112131415#!/bin/bashlanguage='TW';case ${language} in 'TW') echo '中文'; ;; 'EN') echo '英文'; ;; *) echo '看不懂'; ;;esac 迴圈跟大多數語言一樣，均可用 continue(省略後續)、break(結束迴圈)。若是不小心進入無窮迴圈，可用 ^C 結束程式。 for12345#!/bin/bashfor loop in 1 2 3; do echo $loop;done while條件成立會持續執行。 12345678910#!/bin/bashcount=1;# 1 數到 9 (條件小於 10 執行)while [ $count -lt 10 ]; do echo $count; ((count++)) sleep 0.5;done until條件不成立會持續執行。 12345678910#!/bin/bashcount=10;# 10 數到 1 (條件不小於 1 執行)until [ $count -lt 1 ]; do echo $count; ((count--)) sleep 0.5;done 特殊變數可以在執行命令檔案時，帶入參數並且應用。 使用方式: 指令 意義 $0 目前的檔案檔名 $n n 從 1 開始，代表第幾個參數 $# 傳遞到程式或函式目前有幾個參數 $* 傳遞到程式或函式所有參數 $@ 類似 $* 但是在被雙引號包含時有些許不同 $? 上一個指令退出狀態或是函式的返回值 $$ 目前 process PID 1./demo.sh A B 123456789#!/bin/bashecho &quot;$0&quot;;echo &quot;$1&quot;;echo &quot;$#&quot;;echo &quot;$*&quot;;echo &quot;$@&quot;;echo &quot;$?&quot;;echo &quot;$$&quot;; 執行結果就由各位自行去看囉～ 總結此篇文章僅講述一些基本的語法應用，有程式底子的人在學 Shell Script 並不會太困難。 Shell Script 常用於系統管理、自動化操作檔案、自動化重複的指令碼、分析 log 等文件檔案、列印呈現我們想要的資料等… 在熟悉基礎後就可以組合出想要的邏輯進而達到有效率的工作行為。","link":"/2021/07/22/Shell%20Script-%E5%9F%BA%E7%A4%8E/"},{"title":"Solid","text":"其實網路上對SOLID的探討及見解文章已經多不勝數。筆者在此僅記錄自身見解與歷程。 若對該原則理解有誤，請不吝指教。 SOLID? 在程式設計的領域中，SOLID指物件導向編成和物件導向設計的五個基本原則。 當這些原則一起被應用時，可以使程式設計師開發一個容易擴充及維護的系統。 SOLID所包含的原則是通過引發編程者進行軟體原始碼代碼重構的代碼異味清掃。從而使軟體清晰可讀及具可擴展性。 SOLID被典型的應用在測試驅動開發上，且是敏捷開發及自適應軟體開發的基本原則重要組成部分。 S: Single responsibility principle(SRP) 單一職責定義: 1一個類別(class)/方法(method)只能負責一個職責 如果一個類別做了兩件職責，就必須拆成兩個類別。 當類別包含複數職責時，則其內聚力越低。 當類別職責越單純且清楚，則其內聚力越高。 舉例: 如果汽車與飛機皆為交通工具而實作於同一個類別(super obj)中，汽車行為模式為 run 而飛機行為模式為 fly。那該類別內部邏輯會變得雜亂且難以維護。 若將汽車與飛機個別實作，各自物件只要管理自己的權責。即可提高內聚。而特定邏輯修改時只要到對應物件內做調整，也降低了維護的難易度。 結論: 一個 class/method 只做一件事。 遵守 SPR 可為程式提高內聚。 Open/close principle(OCP) 開放/封閉原則定義: 1程式在擴充新功能時，不更動原程式碼或者僅以最小幅度修改程式碼的開發方式。 系統實作完若遇到新需求，必須回頭調整原本做好的程式代碼。而只要修改舊的代碼就可能造成不良副作用 #1。應以最小的幅度來修改已存在的程式碼（甚至不修改)才是最佳的情況。 OCP 使系統保有彈性，可以擴充新功能。若有新需求只要進行新增，而不用修改到舊有程式碼(對修改封閉，對新增開放)。進而杜絕不良副作用的產生。 OCP 只是一個原則，讓程式變得靈活的代價是需要花費額外的時間與精力將程式引入新的抽象層，還會增加程式的複雜度。所以 OCP 原則只適合被套用於經常變更的地方！ (#1)不良副作用: 修改程式內碼造成其他使用的該邏輯的地方產生錯誤，即大家口中的改 A 壞 B。 舉例: 設計車子時，因單一職責(SPR)而對車上零件(車燈、輪胎、引擎)進行模組化。若此時若想將一般輪胎換成雪胎。而去修改一般輪胎的模組(物件)內容，可能造成其他使用該物件的邏輯錯誤。 若遵守 OCP 原則，僅對輪胎新增雪胎模組，在車子內部進行替換組合。則只需新增還不需要修改。拒絕了改 A 壞 B的情況產生。 結論: 只有經常變更的地方需要使用 OCP 原則。 系統對新增開放，修改封閉。 L: Liskov substitution principle(LSP) Liskov替換定義: 12Subtypes must be substitutable for their base types.所有子類別都可以代理父類別的工作。 里氏替換原則原則要能夠成立，介面(interface)/抽象方法(Abstract method) 就必須要遵守定義去實做。 子類別需兌現對父類別的承諾，遵照父類別設計開發。 作為子類別的方法必須和他們父類別的方法操作一致，子類別中可以擁有父類別沒有的特殊功能，但是繼承的方法，功能應該兩者一致的。 子類不只是實現父類別的方法，而且必須名符其實，否則會發生無法預料的事情。 舉例: 雪胎及一般輪胎皆繼承輪胎模組(父類別)，而組裝者可由方法取得材質(function)取得輪胎材質來判斷是否適合組裝。若雪胎擅自更改回傳值為適用地形。就會造成組裝者誤判而產生無法逾期之錯誤。 若遵守 LSP 原則，取得材質(function)方法應該遵循輪胎模組(父類別)設計結構去回傳正確值。即可避免程式的行為變得不可預測。 結論: 子類別必須遵從父類別或介面的設計理念去實作方法。 LSP 是實現 OCP 原則的重要方式，只有當子類別能夠完全替代它們的父類別類時，使用父類別的函數才能夠被安全的重用。 I: Interface Segregation Principle(ISP) 介面隔離定義: 12Clients should not be forced to depend upon interfaces that they don’t use.介面不應該強迫 Client 依賴於它們用不到的方法。 12The dependency of one class to another one should depend on the smallest possible interface.類別之間的相依關係應該建立在最小的介面上 類別與類別之間的關係，應只依賴彼此需要的最少介面，介面不能太肥，應該要細化。 介面的目的都是提供一個讓 Client 端可以使用我們開發模組的管道。 介面處於應用程式與模組之間、或是專案與模組之間，這種關係就如同第三方套件提供服務 API 給一個網站使用。 舉例: 跑車與玩具車皆繼承汽車模組(父類別)，而汽車模組(父類別)存在一方法跑(function)。但玩具車並不具備跑(function)這個行為，若是空實作則違反 LSP 原則。 應該設計兩介面(interface):模型車(interfece)與實車(interface)。而於實車(interface)內部宣告跑(function)方法，再由跑車與玩具車個別去實作對應的介面(interface)。 結論: ISP 可降低商業邏輯（低階模組）與 Client 之間的耦合。 設計模組時，要以 Client 需求的角度建立介面，且避免設計龐多功能的單一介面。 設計介面(interface)的時候，應該考慮單一職責原則，把有關聯的方法放在一起，分割出多個單一功能的介面。 D: Dependency Inversion Principle(DIP) 依賴反轉定義: 12High-level modules should not depend on low-level modules. Both should depend on abstractions.高階模組不應該依賴於低階模組，兩者都該依賴抽象。 12Abstractions should not depend on details.抽象不應該依賴細節。 12Details should depend on abstractions.低階模組的實作內容應該依照抽象的定義去實作。 高階與低階，是相對關係，其實也就是 呼叫者 (Caller) 與 **被呼叫者 (Callee)**。 ￼高階模組直接依賴低階模組，則為高耦合。 不應該讓任何東西直接依賴低階模組。 DIP 由 DI(注入) 與 IOC(控制反轉) 實作。目的為解除耦合性(解偶)。 舉例: 實作汽車時需組裝零件，此時若將零件寫死於汽車中。若其中一項零件停產了或要更換。則需到汽車中修改既有內碼(違反 OCP)。 以輪胎為例，汽車有內碼使用 一般輪胎。而一般輪胎剛好停產或廢棄了。那汽車即會出錯。若是要修改還需要到汽車內碼中將使用 一般輪胎改成使用 新的一般輪胎。 若依照 DIP 設計。將輪胎抽離於組裝者取得並組裝於車上。舉例來說汽車-&gt;組裝輪胎(一般輪胎)。依上述情境若一般輪胎出事了，組裝者只要從外部替換輪胎汽車-&gt;組裝輪胎(新的一般輪胎)。則不用更動汽車程式內碼，汽車與輪胎之間也不具備耦合性。 結論: 介面(interface)應由高階模組去制定規範。 使用介面(interface)確保低階模組開發正確性。 遵守 DIP 可大大降低物件之間的耦合性(解偶)。 依賴反轉原則可以幫助我們遵守其他原則，遵守依賴反轉的過程中會： 拆散類別的職責(SRP)。 更容易達成 OCP。 避免父子類別沒有依照介面的定義實作(LSP)。 拆散介面的職責(ISP)。 ——————-工程師最怕聽到的就是程式又要改。而SOLID原則是前人經過無數經驗統整出使程式具備容易維護且具可擴充性質。讓之後在更動程式或擴充需求時能降低修改既有程式難易度。雖說SOLID原則能使程式品質有實質的躍升，但還是得注意別陷入過度設計。 參考網址物件導向程式設計基本原則 - SOLID 【筆記】物件導向設計 : SOLID 介紹","link":"/2019/11/26/Solid/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/27/hello-world/"},{"title":"正規表示式 - Regular Expression","text":"正規表示式 (Regular Expression)能為你檢查是否為全英文字串！ 很專業！ 正規表示式 (Regular Expression)能為你檢查是否為指定結構字串！ 很貼心！ 正規表示式 (Regular Expression)能為你找出複雜性組成字串！ 很厲害！ What is it?Regular Expression 又稱正規表達式、正規表示法、規則運算式、常規表示法。是一門電腦科學，是用來比對字串是不是有符合正確的格式。 語法簡單，功能強大，最重要的是！幾乎已知的語言都有支援他。包誇了各大編譯器皆有支援。 開始之前讓我們擁有一個實用的線上工具 regex101。 您可以在 TEST STRING 的地方輸入 focus，在於 REGULAR EXPRESS 的地方輸入 focus 或其中一字元都行(注意大小寫)。是否被選起來了呢！ 下面的教學皆可直接扔進線上工具內使用哦！ 注意: 正規表示法使用時前後須由 / 包起來(/a/)，但該工具 REGULAR EXPRESS 中輸入時不用。 語法字元 12a: a字元.: 所有可能的字元(字母、數字或符號)。 RegExp 說明 範例 /a/ 含有字元 a a , ab , ba , bbacc /./ 任意單一字元 a , ab , ba , bbccc , 哈囉 /a./ 含有字元 a 且後面接任意單一字元 a1 , ab , a囉 次數 12345678*: 比對前一個字串 0 次或是多次。?: 比對前一個字串或是不比對。+: + 跟 * 類似，差別在於它至少要與前一個字比對一次或以上。{n,m}: 指定出現次數，n 為最小次數 m 為最大次數。{2}: 2 次。{2,}: 2 次以上。{2,5}: 2 到 5 次。 RegExp 說明 範例 /ba*c/ bc 字元中間，a 字元出現 0 次或是多次。 bc , bac , baaac /ba?c/ bc 字元中間，a 字元出現 0 次或一次。 bc , bac /ba+c/ bc 字元中間，a 字元出現 0 次或一次。 bac , baaac /ba{2}c/ bc 字元中間，a 字元出現 2 次。 baac /ba{2,}c/ bc 字元中間，a 字元出現 2 次以上。 baac , baaac /ba{2,5}c/ bc 字元中間，a 字元出現 2 - 5 次。 baac , baaaaac 條件 1234^: 字串開頭。$: 字串結尾。|: 前字串或者後字串。\\: 跳脫特殊字元。 若要比對正規表示式內部特殊字元(*?+{}[] 等...)，需用反斜線來跳脫這些特殊字元。 RegExp 說明 範例 /^ab/ ab 開頭字串。 ab , abc /ab$/ ab 結尾字串。 ab , cab /acc bcc/ acc 字串或 bcc 字串。 /a\\*/ a*字串。 a* , aa* , a*a 多字元篩選 123[ ] : [] 內所包含字元。[^] : 不存在 [] 內的任何字元。[-] : 連號字元(0-9 a-z A-Z)。 RegExp 說明 範例 /[abc]/ abc 任一字串。 abc , ade , bde , cde /[^abc]/ 非 abc 任一字串。 def , ggg , ddd /[0-9]/ 數字 0 - 9 0123456789 , a0b , 9a8n 在 [ ] 後面接上 {n}，則會取得 [] 中指定數量組合(不分順序)。 1EX: [abc]{2} : `ab` , `cb` , 'ac' 特殊字元 123456\\d: 任何數字字元，等同 [0-9]\\D: 任何非數字字元，等同 [^0-9]\\w: 任何數字字母底線，等同 [A-Za-z0-9_]\\W: 任何非數字字母底線，等同 [^A-Za-z0-9_]\\s: 任何空白字元(空白,換行,tab)，等同 [ \\f\\n\\r\\t\\v]\\S: 任何非空白字元(空白,換行,tab)，等同 [^ \\f\\n\\r\\t\\v] 實例12345678西元生日: 四個數字開頭 - 兩個數字 - 兩個數字結尾RegExp: /^\\d{4}-\\d{2}-\\d{2}$/身分證字號: 英文字母開頭(大寫) 九個數字RegExp: /^[A-Z]\\d{9}$/手機號碼: 國碼開頭(09) 八個數字RegExp: /^09\\d{8}$/ 同場加映Regex matching line not containing the string不包含指定的字元！ 1RegExp: ^((?!YoYo).)*$ Hello YoYo! Hello Hank! 保留差異字元取代 筆者覺得這個超重要，大家一定要會。 在正規表示式中被 () 所選起來的參數可以被保留至變數中。保留變數會由 $1 $2 $3 所使用。 12345678910# 一段句子中，若只替換問候語而保留人名。Hello, YoYo!Hello, Hank!搜尋 RegExp: /Hello, (.*)!/取代 RegExp: /Shit, $1!/# 輸出結果Shit, YoYo!Shit, Hank! 什麼？ 你問我這有什麼用？筆者遇到的問題是，因為語言版本的關係。要將程式內的變數使用 {} 替換為 []; 12345678Ex:$str{0};$str{1};$str{2};$str{3};$str{'name'};$str{'email'}; 總不可能要我一個一個去替換吧！！這邊考考各位，要怎麼一組替代語法將 $str{} 替換成 $str[] ！筆者的答案在下方哦 ※1。 結語Regular Expression 是非常好用的工具，且應用範圍很廣。編譯器對專案全區域搜尋、各程式語言內部使用設置是資料庫應用都可以做出很好的工作效率。 這篇只是筆者對基本 Regular Expression 的介紹。大家能在利用網路資源，進行更深入的學習。 ※1: 12搜尋 RegExp: \\$str\\{([^\\}]*)\\}取代 RegExp: \\$str\\[$1\\]","link":"/2021/02/23/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F%20(Regular%20Expression)/"},{"title":"重新擁抱程式設計 - 淺談 JavaScript","text":"世界上最流行的程式語言之一又號稱世界上被誤解最深的程式語言。 世界上最被人誤解的程式語言 - JavaScriptJavaScript 又名 Mocha、LiveScript、JScript 又或者叫 ECMAScript。 原因如下: The Name 許多人會將 JavaScript 當成是 Java 的子程式、也因為 script 這個字眼，而認為它不是一個真正的程式語言。 Moving Target 初版的 JS 非常的粗糙，沒有例外處理、內部函式、以及繼承的概念。即便現在的版本已經是一個物件導向的程式語言，但初期的壞印象仍讓許多人有既定的印象。 Design Errors JS 與其他語言一樣，有許多設計上的錯誤，例如 + 號同時代表了字串的串接及數值的相加、或者是 with 的使用、Regular Expression 的寫法、保留字的使用太過嚴格，這些設計上的錯誤都讓人在開發過程中產生疑惑。 令人驚訝的是，ECMA 組織似乎沒有要修正這些問題。 Bad Implementations 較早期的錯誤撰寫方式存在許多嚴重的錯誤。更糟糕的是，這些實現被嵌入到令人毛骨悚然的錯誤 Web 瀏覽器中。 Amateurs 通常編寫 Javascript 都是不具有程式語言背景的工程師，寫出來的東西自然就給人奇差無比的觀感。 Bad Books 書籍及文件所提供的錯誤觀念。 Substandard Standard 不夠標準的規範，ECMA 所發布的規格質量極差。這很難閱讀，也很難理解。這是造成 Bad Book 問題的原因，因為作者無法使用標准文檔來提高自己對這種語言的理解。 JavaScript 的名字由來最開始這門語言取名叫「Mocha」，1995 年 9 月 Netscape 宣布要在LiveWire (伺服器端環境) 啟用某個程式語言，於是這門程式語言就被叫做「LiveScript」。 同年 12 月基於行銷考量，為了讓這門語言搭上 Java 這個程式語言「熱詞」，因此將其臨時改名為 JavaScript，日後這成為大眾對這門語言有諸多誤解的原因之一。 所以，Java 跟 JavaScript 到底有沒有關係？除了名字之外，根本沒有關係。之所以名字會很像，只是單純 Netscape 想要蹭熱度罷了。 JavaScript 基礎篇[1]: 變數與資料型別&gt;&gt;&gt;","link":"/2020/12/01/%E9%87%8D%E6%96%B0%E6%93%81%E6%8A%B1%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%20-%20%E6%B7%BA%E8%AB%87%20JavaScript/"},{"title":"HEXO 移機教學","text":"hexo 重新建置環境。 hexo 更換電腦。 小弟剛好換新電腦，在此紀錄移植 hexo 編寫環境紀錄。 檢查編寫環境12345678# 檢查是否有安裝 git$ git --version# 檢查是否安裝 node.js$ node -v# 檢查是否有安裝 hexo$ hexo -v 若環境沒安裝完全，且忘記怎麼裝了: 點我 備份開發環境備份舊電腦的開發文件 新開發環境將備份檔案放置新電腦後，進到對應資料夾，並用 npm 建置原始檔案編譯。 1234567$ cd blog# npm 建立編譯檔$ npm install# 下載 git 工具$ npm install hexo-deployer-git --save 執行看看，看看在本機看看網站有沒有各種毀滅。 12# 可以透過本機的 http://localhost:4000 查看結果$ hexo s --debug 完成後就可以開始快樂得文章編寫拉!!","link":"/2021/09/17/Hexo-%E7%A7%BB%E6%A9%9F%E6%95%99%E5%AD%B8/"},{"title":"設計模式 - 工廠模式(簡單工廠、工廠方法、抽象工廠)","text":"簡單工廠模式 工廠模式 抽象工廠模式 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹工廠模式重點在於情境複雜度度來針對代碼提取及封裝的行為，可以的達到高內聚、低耦合的效果。 工廠模式又細分為以下三種: 簡單工廠模式。 工廠方法模式。 抽象工廠模式。 簡單工廠模式又稱靜態工廠，可以用於較簡單邏輯的業務需求。嚴格來說簡單工廠模式不是一種設計模式，更像是一種開發習慣。 定義透過一個類別來創建其他類別的實例，被創建的實例通常要有共同的父類別。 組成 工廠角色：負責依照內部邏輯返回創建的實例。 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 範例抽象產品角色 1234abstract class Academy{ abstract function announce();} 具體產品角色 123456789101112131415class Gryffindor extends Academy{ public function announce() { echo '葛萊芬多！ &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce() { echo '史萊哲林！ &lt;br/&gt;'; }} 工廠角色 123456789101112131415161718class AcademyFactory{ public static function createAcademy($academy) { switch ($academy) { case 'Gryffindor': return new Gryffindor(); case 'Slytherin': return new Slytherin(); default: echo '無此學院'; return null; } }} 使用工廠 12345# 格萊芬多宣示AcademyFactory::createAcademy('Gryffindor')-&gt;announce();# 史萊哲林宣示AcademyFactory::createAcademy('Slytherin')-&gt;announce(); 輸出結果 12葛萊芬多！史萊哲林！ 討論 該模式依照邏輯判斷實作何種產品的實例，客戶端可以免除直接創建產品的責任。 但若是新增了產品(霍格華滋不單只有兩個學院)，必然修改工廠邏輯，此行為直接違反了開放封閉原則，且在產品過多的情況下，會造成邏輯複雜難以維護的問題。 工廠方法模式屬於『創建型模式』。 定義由父類別定義一個建立物件的介面(工廠方法)**，再由實作的次類別(工廠類別)去實作實體化的動作，工廠方法是一個抽象的方法**。 組成 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 工廠父類別：內含用以實體化的產品的抽象方法。 工廠子類別：實作產生物件的方法。 範例 抽象產品角色及具體產品角色 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Academy{ abstract public function announce(): string; abstract public function feature(): string; abstract public function mascot(): string;}class Gryffindor extends Academy{ public function announce(): string { return '葛萊芬多！ &lt;br/&gt;'; } public function feature(): string { return '強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。 &lt;br/&gt;'; } public function mascot(): string { return '獅。 &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce(): string { return '史萊哲林！ &lt;br/&gt;'; } public function feature(): string { return '有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。 &lt;br/&gt;'; } public function mascot(): string { return '蛇。 &lt;br/&gt;'; }} 工廠父類別 1234abstract class AcademyFactory{ abstract public function introduceAcadmy();} 工廠子類別 123456789101112131415161718192021class GryffindorFactor extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Gryffindor(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); }}class SlytherinFactory extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Slytherin(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); }} 分類帽 123456789echo '哈利波特適合葛萊芬多！ &lt;/br&gt;';$selectAcadmy = new GryffindorFactor();$selectAcadmy-&gt;introduceAcadmy();echo '&lt;/br&gt;';echo '馬份似乎比較適合史萊哲林！ &lt;/br&gt;';$selectAcadmy = new SlytherinFactory();$selectAcadmy-&gt;introduceAcadmy(); 輸出結果 123456789哈利波特適合葛萊芬多！學院：葛萊芬多！特質：強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。代表物：獅。馬份似乎比較適合史萊哲林！學院：史萊哲林！特質：有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。代表物：蛇。 討論 因為工廠模式隱藏了內部實作細節，客戶端只要注重於正確工廠的使用，這使得整個設計符合了單一職責，提高了系統內聚性。 若今日要添加兩個學院(霍格華滋有四大學院)，只要添加對應工廠即可，這樣就不會更改到原有的邏輯，也符合了開放封閉原則。 但由於將實作細節封裝進工廠內部，會導致系統結構複雜化，後續人員的學習曲線會跟著提高。更糟糕的是若設計上有所失誤，會大大提升功能的擴充性及維護性的難度。 抽象工廠抽象工廠注重的是各種不同的產品得實作與組合，父類別會定義多個抽象物件讓次類別(工廠類別)**去實作各個實體化的動作。像是汽車的內裝(不同廠牌的音響)、冒險者的武器(長劍或弓)或是家電的零件(面板來源)**等… 定義由父類別定義多個建立物件的介面(工廠方法)**，再由實作的次類別(工廠類別)去實作各個實體化的組裝動作**。 組成 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 工廠父類別：內含用以實體化的產品的抽象方法。 工廠子類別：實作產生物件的方法。 範例抽象產品角色及具體產品角色(學院，此時多了寶物而未裝備) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class Academy{ protected string $treasure=''; abstract public function announce(): string; abstract public function feature(): string; abstract public function mascot(): string; public function setTreasure($setTreasure) { $this-&gt;treasure = $setTreasure; } public function showTreasure(): string { if (trim($this-&gt;treasure) == '') { return '糟糕，我沒拿到寶物'; } return $this-&gt;treasure; }}class Gryffindor extends Academy{ public function announce(): string { return '葛萊芬多！ &lt;br/&gt;'; } public function feature(): string { return '強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。 &lt;br/&gt;'; } public function mascot(): string { return '獅。 &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce(): string { return '史萊哲林！ &lt;br/&gt;'; } public function feature(): string { return '有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。 &lt;br/&gt;'; } public function mascot(): string { return '蛇。 &lt;br/&gt;'; }} 抽象產品角色及具體產品角色(寶物，待工廠實作組裝給學院生) 123456789101112131415161718192021abstract class Treasure{ abstract public function equipTreasure(): string;}class GryffindorTreasure extends Treasure{ public function equipTreasure(): string { return '格萊芬多寶劍！'; }}class SlytherinTreasure extends Treasure{ public function equipTreasure(): string { return '史萊哲林小金匣！'; }} 工廠(創建學院生並給予寶物) 12345678910111213141516171819202122232425262728293031323334abstract class AcademyFactory{ abstract public function introduceAcadmy();}class GryffindorFactor extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Gryffindor(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); $treasure = new GryffindorTreasure(); $acadmy-&gt;setTreasure($treasure-&gt;equipTreasure()); return $acadmy; }}class SlytherinFactory extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Slytherin(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); $treasure = new SlytherinTreasure(); $acadmy-&gt;setTreasure($treasure-&gt;equipTreasure()); return $acadmy; }} 分類帽(分派學生，且學生高興地舉起手中的寶物) 1234567891011echo '哈利波特適合葛萊芬多！ &lt;/br&gt;';$selectAcadmy = new GryffindorFactor();$potter = $selectAcadmy-&gt;introduceAcadmy();echo '哈利波特：我手上握有' . $potter-&gt;showTreasure() . '&lt;/br&gt;';echo '&lt;/br&gt;';echo '馬份似乎比較適合史萊哲林！ &lt;/br&gt;';$selectAcadmy = new SlytherinFactory();$malfoy = $selectAcadmy-&gt;introduceAcadmy();echo '馬份：我手上握有' . $malfoy-&gt;showTreasure() . '&lt;/br&gt;'; 輸出結果 1234567891011哈利波特適合葛萊芬多！學院：葛萊芬多！特質：強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。代表物：獅。哈利波特：我手上握有格萊芬多寶劍！馬份似乎比較適合史萊哲林！學院：史萊哲林！特質：有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。代表物：蛇。馬份：我手上握有史萊哲林小金匣！ 討論 由工廠去組裝各個實作產品，讓各部件的組合更具重用性及靈活性。充分達到高內聚、低耦合的設計目的。 增加新的具體工廠和產品族很方便，不需要修改已有的系統，非常符合開放封閉原則。 因為間有組合的關係，要修改結構是相當麻煩的。","link":"/2021/09/27/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F(%E7%B0%A1%E5%96%AE%E5%B7%A5%E5%BB%A0%E3%80%81%E5%B7%A5%E5%BB%A0%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0)/"},{"title":"AES 資料加密","text":"進階加密標準（英語：Advanced Encryption Standard，縮寫：AES），在密碼學中又稱 Rijndael 加密法，是美國聯邦政府採用的一種區塊加密標準。 加密方式比對 對稱加密：採用單密鑰的加密方法，同一個密鑰可以同時用來加密和解密。常用的對稱加密算法有 DES，3DES，AES 等。 非對稱加密，需要兩個密鑰來進行加密和解密，這兩個密鑰是公開密鑰（public key，簡稱公鑰）和私有密鑰（private key，簡稱私鑰）。常用的非對稱加密算法有 RSA，Elgamal，ECC 等。 簡單做一下兩者的比對: 功能特性 對稱加密 非對稱加密 密鑰特徵 加密方和解密方使用同一個密鑰 加密方和解密方使用不同的密鑰 加密效率 效率高，速度快 速度慢 密鑰安全性 傳輸過程中容易洩漏 安全性高 設計思維 安全性(Security) ：演算法足夠強，抗攻擊。 經濟性(Efficiency) ： 演算法運算效率高。 金鑰捷變(Key Agility) ：更改金鑰所引入的損失儘量小，即最小消耗的金鑰擴充套件演算法。 適應性 (Versatility) ：適用於不同的CPU架構，軟體或硬件平臺的實現。 設計簡單(Simplicity) ：輪函式的設計精簡，只是多輪迭代。 評判要求NIST在徵集演算法的時候就提出了幾項硬性要求： 分組加密演算法：支援 128 位分組大小，128/192/256 位金鑰 。 安全性不低於 3DES，但實施與執行要比 3DES 的更高效 。 優化過的 ANSI C 的實現程式碼 KAT(Known-Answer tests) 及 MCT(Monte Carlo Tests) 測試及驗證 。 軟體及硬體實現的便捷 。 可抵禦已知攻擊。 設計準則 混淆 (Confusion) 最大限度地複雜化密文、明文與金鑰之間的關係，通常用非線性變換演算法達到最大化的混淆。 擴散 (Diffusion) 明文或金鑰每變動一位將最大化地影響密文中的位數，通常採用線性變換演算法達到最大化的擴散。 實作原理AES算法主要有四種操作處理，分別是輪 密鑰加層(Add Round Key) 、 字節代換層(SubBytes) 、 行位移層(Shift Rows) 、 列混淆層(Mix Columns) 。AES加密的過程，並不是明文和密鑰簡單運算一下。 在上面的幾個步驟中，我們是對輸入對數據進行混淆。 AddRoundKey每執行一次叫做一輪加密，這一步會執行多次。簡單來說就是把密鑰和混淆後的結果進行 xor 運算，但在每一輪使用的密鑰都是根據上一輪的密鑰變換而來的。 看一下動畫： (圖片來源) 加密模式AES只能對固定長度的數據進行加密，對於不定長的數據，我們需要把它切分成若干定長的數據，再進行加密解密，這就是我們常說的分組加密。分組加密有 ECB、CBC、CFB、OFB 這幾種加密模式，我們介紹一下 ECB 模式和 CBC 模式。 ECB：最簡單的塊密碼加密模式，加密前根據加密塊大小（如AES為128位）分成若干塊，之後將每塊使用相同的密鑰單獨加密，解密同理。具體見圖： ECB 模式由於每塊數據的加密是獨立的，所以可以分塊進行並行加密或者解密。它的缺點是相同的明文塊會被加密成相同的密文塊，所以這種方法在某些條件下安全性相對不是很高。 CBC：每個待加密的密碼塊在加密前會先與前一個密碼塊的密文異或然後再用加密器加密，第一個明文塊與一個叫初始化向量IV的數據塊異或。具體見下圖： 完成加密或解密後會更新初始化向量IV，CBC模式安全性更高，但由於對每個數據塊的加密依賴前一個數據塊的加密，所以加密是無法並行的。 PHP 實作12345678910111213141516$sourceKey = &quot;TestKey&quot;;$sourceIv = &quot;TestIV&quot;;$cypher = &quot;AES-256-CBC&quot;;$options = OPENSSL_RAW_DATA; //OPENSSL_RAW_DATA、OPENSSL_ZERO_PADDING$key = substr(hash(&quot;sha256&quot;, $sourceKey), 0, 32);$iv = substr(hash('sha256', $sourceIv), 0, 16);# 加密$e = base64_encode(openssl_encrypt('YoYoLin', $cypher, $key, $options, $iv));# 解密$d = openssl_decrypt(base64_decode($e), $cypher, $key, $options, $iv);echo $e;echo '&lt;/br&gt;';echo $d; Mysql 實作12345678# 設置模式SET block_encryption_mode = 'aes-256-cbc';# 輸出加密字串 (str, key, iv)SELECT TO_BASE64(AES_ENCRYPT('我是小飛俠', 'd713884fffad4dc8dd5da087efde2287', 'a49eed4cb8bddb3a')) AS AS 加密字符串# 輸出解密字串 (str, key, iv)SELECT AES_DECRYPT(FROM_BASE64(&quot;IrNseqV16ZDYZWNiI4fAcA==&quot;),'d713884fffad4dc8dd5da087efde2287', 'a49eed4cb8bddb3a') AS解密字符串","link":"/2021/10/01/AES%20%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86/"},{"title":"PHP - Aes 加密上傳檔案","text":"手把手 PHP 針對上傳檔案做 AES 加解密教學。 各位看倌，若是對 Aes 不太了解可以看這篇呦。 事前準備需要各位看倌，請先幫我準備好 PHP 執行環境並建立同下圖的資料結構。 boss_o.jpeg 是一張由 Google 上抓取的圖片，作為範例檔案使用。 decode 放置解密後資料位置。 encrypt 放置加密後資料位置。 index.php 主程式，實作程式內部邏輯。 來點簡單的檔案上傳 1234567891011121314151617181920&lt;?php# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; # 檔案位置 $dest = 'encrypt/' . $_FILES['file']['name']; # 將檔案移至指定位置 move_uploaded_file($file, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 只是一個簡單的檔案上傳邏輯，確保上傳檔案有成功放至資料夾 encrypt 內。 將上傳的檔案做加密的動作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php# 加密function encrypt($key, $payload){ $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('aes-256-cbc')); $encrypted = openssl_encrypt($payload, 'aes-256-cbc', $key, 0, $iv); return base64_encode($encrypted . '::' . $iv);}# 寫入檔案function setFile($msg, $dest){ //取出目錄路徑中目錄(不包括後面的檔案) $dir_name = dirname($dest); //如果目錄不存在就建立 if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true); } //開啟檔案資源通道，不存在則自動建立 $fp = fopen($dest, &quot;w&quot;); //寫入檔案 fwrite($fp, $msg); //關閉資源通道 fclose($fp);}# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; $dest = 'encrypt/' . $_FILES['file']['name']; $e = encrypt('testKey', file_get_contents($file)); setFile($e, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 此處將上傳的檔案內容取出做 AES 加密的行為，再將加密資料存回檔案。 透過 openssl_encrypt 加密內部資料，再由 base64_encode 將加密資料進行編碼以便儲存。 此處筆者將 iv 值放置加密資料後面，方便解密。 setFile 是簡單的建立檔案並寫入內容邏輯。 將加密過的檔案做解密的動作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php# 解密function decode($key, $garble){ list($encrypted_data, $iv) = explode('::', base64_decode($garble), 2); return openssl_decrypt($encrypted_data, 'aes-256-cbc', $key, 0, $iv);}# 寫入檔案function setFile($msg, $dest){ //取出目錄路徑中目錄(不包括後面的檔案) $dir_name = dirname($dest); //如果目錄不存在就建立 if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true); } //開啟檔案資源通道，不存在則自動建立 $fp = fopen($dest, &quot;w&quot;); //寫入檔案 fwrite($fp, $msg); //關閉資源通道 fclose($fp);}# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; $dest = 'decode/' . $_FILES['file']['name']; $d = decode('testKey', file_get_contents($file)); setFile($d, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 上傳加密後的檔案，並透過 base64_decode 及 openssl_decrypt 逆向將檔案解密出來。若正確解密的話能在資料夾 decode 內看到解密後的檔案。 注意加密及解密時的 Key 要是一至的。 由於 iv 值 被存於加密後檔案後面，實作上只要管控好 Key 就好。 後話 由於 file_get_contents 是將檔案內容全部存於記憶體內，所以要注意檔案大小及 PHP 開放記憶體是否充足。 加解密 key 及 iv 數值保管，可由看倌們自行決定。 上述為普通的家解密邏輯實作及介紹，懶人包可直接抓取 CODE。","link":"/2021/10/08/PHP-Aes%E5%8A%A0%E5%AF%86%E4%B8%8A%E5%82%B3%E6%AA%94%E6%A1%88/"}],"tags":[{"name":"程式設計","slug":"程式設計","link":"/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"GIT","slug":"GIT","link":"/tags/GIT/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Linux 基本指令","slug":"Linux-基本指令","link":"/tags/Linux-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"},{"name":"crontab","slug":"crontab","link":"/tags/crontab/"},{"name":"排程","slug":"排程","link":"/tags/%E6%8E%92%E7%A8%8B/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Schell Script","slug":"Schell-Script","link":"/tags/Schell-Script/"},{"name":"SOLID","slug":"SOLID","link":"/tags/SOLID/"},{"name":"設計模式","slug":"設計模式","link":"/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"},{"name":"資料加密 - Aes - PHP - Mysql","slug":"資料加密-Aes-PHP-Mysql","link":"/tags/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86-Aes-PHP-Mysql/"}],"categories":[{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"資料庫","slug":"資料庫","link":"/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"},{"name":"Schell Script","slug":"Schell-Script","link":"/categories/Schell-Script/"},{"name":"程式設計","slug":"程式設計","link":"/categories/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"設計模式","slug":"設計模式","link":"/categories/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"},{"name":"Aes","slug":"Aes","link":"/categories/Aes/"}]}