{"pages":[],"posts":[{"title":"GIT 還原單一檔案","text":"GIT 如何還原已修改檔案。 GIT 如何將檔案還原至 commit 前版本。 GIT 如何將檔案還原至指定版本。 首先，讓我們看一下 LOG 紀錄。 1$ git log 直接還原已修改檔案直接還原即可，以下兩種語法效果相同。 121. $ git checkout &lt;file&gt;2. $ git checkout -- &lt;file&gt; 還原已 commmit 檔案對於已經 commit 上版控(尚未 push)，用以下步驟還原。 先用 reset 解除 commit 操作。 1$ git reset HEAD^ 如圖中，測試 COMMIT 版本 1 的紀錄會被移除。並保留其修改內容。若是對應檔案有在做修改，會以後續修改版本為主。 再用 checout 還原更改檔案。 1$ git checkout &lt;file&gt; 還原檔案至版控上指定紀錄版本可由圖片中看到各版本的 commit Hash。使用以下語法還原至對應版本。 1$ git checkout &lt;commit Hash&gt; &lt;file&gt; 小知識: Hash 只要取前四碼即可。","link":"/2021/06/12/GIT%E9%82%84%E5%8E%9F%E5%96%AE%E4%B8%80%E6%AA%94%E6%A1%88/"},{"title":"HTML JS 動態顯示 input file 選取內容","text":"使用 HTML 取得本地檔案1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; File API 可以從 File 物件中讀取 FileList ，FileList 內包含使用者所選取的檔案。如果使用者只選擇一個檔案，那麼我們只需要考慮第一個檔案物件。 使用 DOM 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = document.getElementById('testFile').files[0]; 使用 JQUERY 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = $('#testFile').get(0).files[0]; 使用 change event 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; onchange=&quot;selectFile(this.files)&quot; /&gt; JS: 123function selectFile(files) { var file = files[0];} 獲得選取的檔案資訊上述的例子顯示獲取在檔案清單裡所有檔案物件的方法。File 提供三個包含檔案重要訊息的屬性。 name: 唯讀的檔案名稱，並未包含檔案路徑。 size: 為 64 位元的整數，用以表示檔案的 byte 的長度。 type: 為唯讀字串。表示檔案的 MIME-type 。若是無法取得檔案的 Mime-type ，則其值會是一個空字串 “”。 使用 FileReader 讀取文件內容讀取文字HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectTextFile(this.files)&quot; /&gt;&lt;p id=&quot;showText&quot;&gt;&lt;/p&gt; JS: 12345678910111213function selectTextFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showText').src = this.result; }; reader.readAsText(file);} 當然也可以讀取圖片HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectImgFile(this.files)&quot; /&gt;&lt;img id=&quot;showImg&quot;&gt;&lt;/img&gt; JS: 12345678910111213function selectImgFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showImg').src = this.result; }; reader.readAsDataURL(file);} Code Demo","link":"/2020/08/17/HTML-JS-%E5%8B%95%E6%85%8B%E9%A1%AF%E7%A4%BA-input-file-%E9%81%B8%E5%8F%96%E5%85%A7%E5%AE%B9/"},{"title":"Hexo","text":"操作指令12# 開啟服務hexo server 12# 同步指令hexo d -g 細節待補","link":"/2019/11/29/Hexo/"},{"title":"GIT 查看&#x2F;匯出差異檔案","text":"查看指定 commit 修改過檔案差異。 匯出指定 commit 修改過檔案差異 Diff 比對差異檔案1$ git diff 說明: 比對當下**未進暫存區(Add)**所有檔案區別。 1$ git diff --cached 說明: 比對當下**已進暫存區(Add)**所有檔案區別。 1$ git diff &lt;filename&gt; 說明: 比對當下未進暫存區(Add)單一檔案區別。 想一想: 那已進暫存區(Add)單一檔案區別呢？ 1$ git diff &lt;commit-hash&gt; 說明: 比對指定 commit 與 HEAD 檔案區別 1$ git diff &lt;old commit-hash&gt; &lt;new commit-hash&gt; 說明：比對兩個 commit 之間的差異． 比較常用的指令集1234567891011$ git diff HEAD^ HEAD # 比較最新版與最新版前一次版本的差異$ git diff ---stat # 檢視更新的簡略統計資訊。$ git diff --name-only # 在更新的訊息後方顯示更動的檔案列表。$ git diff --name-status # 顯示新增、更動、刪除的檔案列表。$ git diff --diff-filter= [(A|C|D|M|R|T)…​[*]]] # 配合檔案狀態來篩選顯示檔案列表。# A = Added# C = Copied# M = Modified# R = Renamed# T = Changed# D = Delete 讓我們產出差異的檔案清單 1$ git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD diff-tree: 比較兩個 commit 之間的差異。 -r: 列出完整路徑。 –name-only: 不輸出 commit hash –diff-filter=ACMRT: 列出指定類型檔案。 HEAD: 當下版本，可改為任一或多個 commit hash 將結果輸出為 txt 檔1$ git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD &gt; test.txt 匯出差異檔案(含完整路徑)1$ git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD) 注意: 若沒加 $() 內部篩選，會打包整個專案。 小知識 commid hash 只要取前四碼就可以了。 git archive 一定要在版控系統根目錄執行才有作用。","link":"/2021/08/11/GIT%E6%9F%A5%E7%9C%8B:%E5%8C%AF%E5%87%BA%E5%B7%AE%E7%95%B0%E6%AA%94%E6%A1%88/"},{"title":"Interface","text":"Interface 又稱 介面 接口 契約 介面本身是抽象的。指一系列的 Public 屬性或函式。所以你的物件，即便沒有實作任何介面他本身也是一個介面。它提供的介面就是自己所有 Public 的屬性跟函式。 介面可以確保依賴物件提供你想要的功能。 每個物件都是實作介面。 創造物件實作基礎介面，你的物件就可以執行語言的基礎函式 ex: foreach。 舉例: PHP 中的 array 也是實作幾個陣列功能會用到的 interface 還記得一個物件可以實作多個介面嗎？這裡會牽扯到兩個物件的耦合程度。假設你的函式宣告參數的型別是宣告成某個介面。那你在函式裡面只會拿到介面的 Public 屬性跟函式。但是如果你把參數的型別直接宣告成某個物件，在函式裡面就會拿到物件的所有 Public 屬性跟介面。 如果你的函式只需要其中一個介面提供的功能，那就在把參數的型別指定為介面就好。否則你會依賴整個物件。 結論你會發現整個語言都是照著介面在開發。所以有人常說 programin to a interface。介面只是定義一個抽象的概念，至於要實作成什麼樣子，是需要按照需求來決定。 重點是 interface 或抽象類別，都是向上層程式碼保證他們能提供指定的功能。 – 小知識: C＃ 跟 Java 一定會宣告參數的型別。這個叫做 Type hint，如果丟進去的參數不符合型別，編譯時就報錯。所以被叫做強型別語言。 PHP 跟 JS 沒有強迫一定要有 Type hint。稱作弱型別語言。","link":"/2019/11/26/Interface/"},{"title":"JavaScript基礎篇[1] 變數與資料型別","text":"JavaScript 基礎 – 變數與資料型別。 變數可以將變數想像為一個盒子，是用來存放資料的。 在 JavaScript 中的變數宣告是有規則的，開頭必須是英文字母、底線(_)或錢字號($)，後面可以接著英文字母、底線(_)或錢字號($)以及數字。變數名稱不可以是保留字(Reserved Words) 與關鍵字(keyword)。 JavaScript 是有區分大小寫的，變數 apple 與 Apple 將會被視為不同的兩個變數。且 1.3 版之後支援 Unicode。代表著你可以用中文來當變數名稱。 但還是避免使用非英文字母來做變數名稱命名，用中文編碼的話，其他語系系統開啟可能會造成亂碼的情況。 變數在使用前，可以透過 var 來進行宣告的動作。在 ES6 之後多了 let 與 const 兩種。由於 JavaScript 是個 弱型別[註1] 的語言，變數本身無需宣告型別，型別的資訊只在值或物件本身。 12345// 透過 var 宣告變數 apple 但沒賦予其值，此時 apple 的內容為 undefined。var apple;// 透過 var 宣告變數 apple 且賦予其值，此時 apple 的內容為 'apple'。var apple = 'apple'; 若沒宣告變數就要使用的情況下，會出現 ReferenceError。 如下: 1console.log(hello); 或許你會發現，即便沒有用 var 進行變數宣告，仍可以定義變數並給予值。但強烈不建議這麼做。因為，沒有使用 var 宣告的變數，全都會變成全域變數。 全域變數 後續再做解說。 12apple = 'apple';console.log(apple); // 沒錯，就是 'apple'。 註1: 程式語言中，是有型別系統(type system)的。區分為強型別、弱型別。強型別語言在定義變數時就必須給予變數指定型別，若這個變數做了錯誤型別運算，則會出現錯誤。弱型別語言則相反，雖然多了許多方便性，但要注意型別轉換時可能產生的非預期錯誤。 資料型別 變數沒有型別，值才有。 由於 JavaScript 是個弱型別的程式語言，嚴格來說，變數本身其實不帶有資料型別的資訊，其中的值或物件才有。 JavaScript 的型別主要可分為原始型別(Primitives)與物件型別(Object)。 原始型別包含了 string、number、boolean、null、undefined。而在 ES6 中多了 Symbol。 12345typeof true; // 'boolean'typeof 'apple'; // 'string'typeof 123; // 'number'typeof { }; // 'object'typeof [ ]; // 'object' string 字串字串需用單引號 ' '或雙引號 &quot; &quot;包住，兩者不可混用，意思是誰開頭就要誰結尾。 單引號與雙引號的使用在 JavaScript 沒有什麼差異，依習慣使用即可。 12var str = '我是字串';var str2 = &quot;我也是字串&quot;; 若引號不成雙對的話會出狀況，如: 12var str = 'Let's go!'; // Errorvar str = &quot;Let's go!&quot;; // OK 如果真的非用單引號不可，則可用 \\(跳脫字元 escape character)處理: 1var str = 'Let\\'s go!'; // OK 組合字串用 +: 1var str = 'Hello, ' + 'word.'; 字串太長需換行銜接可用 \\: 123var str = '這是第一行 \\這是第二行 \\這是第三行'; 注意: \\ 後面不能有東西呦，包含空白。 number 數字JavaScript 僅有的一種數值的型別，不管整數或小數點都是。 12var num = 1;var num = 1.2; 特殊的數字 Infinity (無限大)、-Infinity (負無限大)，以及 NaN。備註: NaN 不是數值。 正數除以 0 會得到 Infinity (無限大)，負數除以 0 會得到 -Infinity (負無限大)。 12var num = 1 / 0; // Infinityvar num = -1 / 0; // -Infinity 那 0/0 呢？ 結果是 NaN。甚至是 Infinity / Infinity 或 -Infinity / -Infinity 也會都得到 NaN。NaN 是個有趣的存在，字面上的意思是 Not a Number。但用 typeof 來判斷，他又告訴你它是 number。 1console.log(typeof NaN); // number NaN 無法做任何數字的運算，結果都會是 NaN。也就是說 NaN 不屬於任何數字，甚至是自己。 1NaN === NaN; // false 所以我們需要 isNaN 函示來檢查它: 1234isNaN(NaN); // trueisNaN(123); // falseisNaN(&quot;123&quot;); // false, 因為字串 &quot;123&quot; 可以透過隱含的 Number() 轉型成數字isNaN(&quot;NaN&quot;); // true, 因為字串 &quot;NaN&quot; 無法轉成數字 順帶一提，JavaScript 的 number 也是基於 IEEE 754 來實作。所以當你執行 0.1 + 0.2 == 0.3 時。 為什麼呢！？這是因為… 自己看 Why 0.1 + 0.2 !== 0.3 不僅是 JavaScript 會產生這種問題，只要是採用 IEEE 754 的浮點數編碼方式來表示浮點數時，全都會產生這類問題。 boolean 布林值 JavaScript 中，所有的東西都可以轉換為 boolean。 boolean 就簡單多了，其值只有兩種: true、false。是由發明的科學家 George Boole 命名。 123var a = true;var b = false;var c = (2 &gt; 1); // true null &amp; undefined若使用 Boolean() 將 null 與 undefined 轉換為布林值，結果都會是 false。但兩者間仍有意義上的差別，故將它們放在一起講。 兩者的共通點是都只有一種值，null 僅有 null，undefined 僅有 undefined。 12var a; // undefined, 宣告卻未給值。var b = null; // null, 明確給予變數 null。 undefined 代表的是**(此變數) 還沒有給值，所以不知道是什麼**。 null 代表的是此變數可能曾經有值)，但現在沒有值。 也可以使用 Number() 強制轉換為數字來看出什麼。 12Number( null ); // 0Number( undefined ); // NaN 還有一點有趣的事，在非全域作用範圍下 undefined 允許被當成是變數使用。 12345(function() { var undefined = 'apple'; console.log(undefined); // apple console.log(typeof undefined); // string})() 甚至是被當成參數來用: 1234(function(undefined) { console.log(undefined); // apple console.log(typeof undefined); // string})('apple') 我看還是別這樣惡搞你的程式了吧。搞同事的就好！ 基礎篇[2]: —&gt;&gt;&gt;","link":"/2020/12/06/JavaScript-%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5/"},{"title":"Javascript FormData 應用","text":"Javascript FormData 應用。Javascript 傳送 File 檔案。 What is FormData? 所有向伺服器提交的 HTTP 資料，都是一個表單 FromData 是一種容器，用來模擬表單，向伺服器提交資料，最大的優點是可以傳送二進制文件（File、Blob），簡單來說它就是一個 Object。 建立方式有兩種，第一種是由 HTML 去建立: 123456789&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;/form&gt;&lt;script&gt; var fd = new FormData(document.getElementById(&quot;Form&quot;));&lt;/script&gt; 注意: 若此處使用 JQuery 去取得 form 表單，會出現錯誤 Uncaught TypeError: Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'. 這是因為 JQuery 取得的是一個數組，而不是 dom 節點，可用以下方式轉換為節點。 12345// $('#Form').eq(0)[0];&lt;script&gt; var fd = new FormData($('#Form').eq(0)[0]);&lt;/script&gt; 第二種是透過 Javascript 去建立。 12var fd = new FormData();fd.append('name', 'YoYo'); 實際應用若是要使用 append 方式來放置 file 資料時，可以這麼做。而後端取得方式與 form 表單直接送出無異。 ex: $_FILES(PHP) 1234567891011121314151617181920212223242526272829&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot; &gt;test&lt;/button&gt;&lt;/form&gt;&lt;script&gt;$('#btn').on('click', function () { // 資料建置 var file_data = $('#file').prop('files')[0]; var fd = new FormData(); fd.append('file', file_data); fd.append('name', $('#name').val()); // 傳送請求 $.ajax({ type: &quot;POST&quot;, contentType: false, processData: false, url: url, data: fd, success: function (data) { // TODO } });});&lt;/script&gt; 觀看資料直接使用 console.log 去呈現 FormData 是會看不到東西的，我們可以用 forEach 將資料放到另一個 Obj 再做呈現。 1234567891011121314151617181920212223&lt;form id=&quot;Form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot; &gt;test&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $('#btn').on('click', function () { // 資料建置 var file_data = $('#file').prop('files')[0]; var fd = new FormData(); fd.append('file', file_data); fd.append('name', $('#name').val()); // 資料輸出 var object = {}; fd.forEach((value, key) =&gt; { object[key] = value; }); console.log(object) });&lt;/script&gt;","link":"/2021/04/14/Javascript%20FormData%20%E6%87%89%E7%94%A8/"},{"title":"Linux 修改檔案名稱","text":"Linux 單次修改檔案名稱。 Linux 批次修改檔案名稱。 單檔案命名用 mv指令 mv，其實最主要的功能是拿來搬移檔案，不過在搬移的時候能夠進行重新指定檔名，所以就被順理成章的成為我們重新命名的指令了。 12# 指令 舊檔案 新檔案$ mv old_file new_file 多檔案命名用 renamerename 指令可以做大量的檔案更名，它使用 perl 的正規表式法來訂定格式，也稱為 perl-rename，因此 prename 與 rename 兩個指令是相同的。不過在 Ubuntu 20.04 之後，rename 指令已經沒有內建了，必須自行安裝。 在 Ubuntu 20.04 內建有另一款叫 rename.ul 的更名指令，兩個指令的使用方法並不相同，這邊先以 perl rename 來試範一些我常用的更名方法。 安裝Ubuntu 20.04 安裝 rename（Ubuntu 18.04 以前已內建） 123$ sudo apt install rename# or$ brew install rename 基本用法1$ rename 's/原字串/新字串/' 要改的檔案 -n：僅列出更名後的結果，不會真的進行更名，建議更名前一定要檢查。 -d：不對資料夾做更名，僅針對目標路徑下的檔案。 基本檔名更改將 A1、A2、A3 改為 B1、B2、B3 12# 所有檔案$ rename 's/A/B/' * 若碰到需要修改特殊字元，需再前面加上反斜線(\\)。 在開頭/結尾插入文字將 A1、A2、A3 改為 ZA1、ZA2、ZA3 12# 所有檔案$ rename 's/^/Z/' * 將 A1、A2、A3 改為 A10、A20、A30 12# 所有檔案$ rename 's/$/Z/' * 批次更改副檔名將 .html 改成 .phtml 12# 所有 .html 結尾的檔案$ rename 's/\\.html$/\\.phtml/' *.html .的前面需加上跳脫符號\\。 原檔名加上$是因為要改的是結尾的副檔名，沒有加$的話，如果原檔名中也有 html 的字串，會被一併更改。 大小寫轉換大寫轉小寫 1$ rename 'y/A-Z/a-z/' * 小寫轉大寫 1$ rename 'y/a-z/A-Z/' *","link":"/2021/07/01/Linux%20%E4%BF%AE%E6%94%B9%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1/"},{"title":"Linux 排程設定(crontab)","text":"linux 排程設定。 linux crontab 設定。 linux 自動工作設定 crontab 設定。 夠了哦！！… 查看與編輯查看自己 crontab 1crontab -l 查看指定使用者的 crontab 1sudo crontab -u username -l 編輯自己的 crontab 1crontab -e 編輯指定使用者的 crontab 1sudo crontab -u username -e 刪除所有 crontab – 注意: 是所有!!! 1crontab -r 設定在 crontab 設定中，每一行設定就代表一個定期排程。 基本設定格式如下: 1MIN HOUR DOM MON DOW CMD 欄位 說明 解說 MIN 分鐘 0 - 59。 HOUR 小時 0 - 23。 DOM 日 1 - 31。 MON 月 1 - 12，可用英文縮寫 Ex: Jan。 DOW 星期 0 - 7，0 與 7 的是星期日。也可用英文縮寫 Ex: Sun。 CMD 執行指令 任何可執行的程式或指令稿。 特殊符號 字元 說明 *(星號) 代表接受任意時刻。 若在月份那一欄填入星號，則代表每一月份皆會執行指令。 ,(逗號) 代表分隔時段。 如果要下達的工作是 3:00 與 6:00 時，就會是： 0 3,6 * * * CMD -(減號) 代表一段時間範圍內。 8 點到 12 點之間的每小時的 20 分都進行一項工作：20 8-12 * * * CMD /n(斜線) n 代表數字，亦即是『每隔 n 單位間隔』的意思，例如每五分鐘進行一次，則：*/5 * * * * CMD 開始設定由於需要設定的內容很多又不方便記憶，所以可以將下列註解貼在開頭。 1234567# ┌───────────── 分鐘 (0 - 59)# │ ┌─────────── 小時 (0 - 23)# │ │ ┌───────── 日 (1 - 31)# │ │ │ ┌─────── 月 (1 - 12)# │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日)# │ │ │ │ │# * * * * * command 以下是一些基本的範例，指令為寫入觸發時間。 注意: 確認執行路徑是否可行，可先將 cmd 指令拿去執行看是否可行。 12# 輸出觸發時間至指定位置date &gt;&gt; ~/text.txt 12345678# 每五分鐘執行一次*/5 * * * * date &gt;&gt; ~/text.txt# 每日早上 8 點到 12 點，整點執行0 8-12 * * * date &gt;&gt; ~/text.txt# 每月 1 日 、15 日、29 日 凌晨五點各執行一次0 5 1,15,29 * * date &gt;&gt; ~/text.txt 設定好後儲存，即可生效！ 實用工具 Crontab Guru，能夠幫你轉換為人類可讀時間。","link":"/2021/03/12/Linux%20%E6%8E%92%E7%A8%8B%E8%A8%AD%E5%AE%9A(crontab)/"},{"title":"Mac建置自製Apache教學","text":"在 Mac 上建立自製 Apache 環境筆者心情小語…當你開心的遛個狗，哼哼小曲沒事想說更新一下心愛的 MAC 突然 Apache 開發環境就被 MAC OS 給狹持了(設定重置)!! 所以說 Apache 開發環境必須獨立! 特別感謝: 給力小夥伴指導我許多 LINUX 與 APACHE 相關設定及觀念。 為什麼要自製 Apache 環境MAC OS 更新版本有時都會突然的重置原生 Apache 設定。 特別是此次 OS 10.14，連 PHP 外部建置環境都給禁止了!! 若您是使用套件架設環境(MAMP、LAMP、XMAPP等…)，那您可能不會有太大的感悟。 但若是您用的是 MAC 提供的原生 Apache，那您可能連做個系統小更新都要小心翼翼的。 此處筆者用 HomeBrew 進行自製 Apache 環境建置。 需求 Mac OS(Linux) 系統電腦一台。 HomeBrew 開始建置吧 關閉 Mac OS 原生的 Apache 並防止他自行啟動 12345// 關閉 apache$ sudo apachectl stop// 禁止 apache httpd 自動啟動$ sudo launchctl unload /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/null 使用 HomeBrew 安裝 apache 1$ brew install httpd 通過指令檢查 apache 安裝，路徑應該被更改為 /usr/local/bin/apachectl 1$ which apachectl 確認啟用指令被改寫後，重啟 apache 1$ sudo apachectl -k start 設置預設啟用程序 1$ sudo brew services start httpd 設置 apache 基礎設定 brew 建置的 Apache 位置為: /usr/local/etc/httpd 編輯 httpd.conf 修改以下項目: Listen 80 ServerName localhost DocumentRoot &quot;/usr/local/var/www&quot; 開啟 rewrite_module (移掉 #): LoadModule rewrite_module lib/httpd/modules/mod_rewrite.so 至此， apache 應已建置完成並啟用。 連結網站吧！ 後話若您是剛開始進行網站架設，那後續 PHP 安裝可透過 brew 安裝。也可透過 Liip 進行後續環境建置。 請繼續往下走。 若您與筆者一樣是遭逢巨變而需要重新建置新環境。那後續設定僅需由 Mac Apache 那邊移植設定檔即可(注意設定檔不可直接使用，許多路徑都不同了)。 Liip 部分 筆者是自行移植載入檔案(/etc/apache2/other)，並於 httpd.conf 下自行添加 Include /usr/local/etc/httpd/other/*.conf。 HomeBrew 建置 PHP 環境待補 Liip 建置 PHP 環境待補 小知識: Mac OS 是使用 plist 文件設置程序隨機啟動。 plist 文件分佈在: /System/Library/LaunchDaemons/ 中，其中指令 apache 及 httpd 相關配置文件為 org.apache.httpd.plist。 使用 brew 不需 root 身份，若以 root 身份執行會被停止且警告。","link":"/2019/11/29/Mac%E5%BB%BA%E7%BD%AE%E8%87%AA%E8%A3%BDApache%E6%95%99%E5%AD%B8/"},{"title":"Mysql 帳號管理","text":"Mysql 帳號權限管理Mysql 帳號新增Mysql 帳號修改Mysql 外部連線 User 權限觀看1234# 查看登入 User 權限，以下語法效果皆相同。SHOW GRANTS;SHOW GRANTS FOR CURRENT_USER;SHOW GRANTS FOR CURRENT_USER(); 12# Show 出系統所有的 UserSELECT User,Host FROM mysql.user; 12# 查看指定帳號SHOW GRANTS FOR root@localhost; 帳號管理123# 新增帳號 (帳號) (IP) (密碼) CREATE USER 'test'@'localhost' IDENTIFIED BY '1234'; 此帳號設定 IP 的 localhost 代表只能在本機登入，若是想開放遠端登入，須將 localhost 修改為對應 IP 或是不限制的話可以設定 **%**。 12# 密碼修改ALTER USER 'test'@'localhost' IDENTIFIED BY '2222'; 讀者們或許會在別的地方看到 set password、update mysql.user set password 的更新密碼方式，上述方式於 Mysql 5.7 版後已不適用。 12# 刪除帳號DROP user test@localhost ; 編輯權限1234567# 調整對應帳號權限 (操作權限) (帳號) (密碼)GRANT ALL ON *.* TO 'test'@'localhost' IDENTIFIED BY '2222' WITH GRANT OPTION; (資料庫).(資料表) # 重新整理FLUSH PRIVILEGES; 操作權限: create,alter,drop,select,insert,update,delete(全部都要的話可用 ALL)。 資料庫/資料表: 可針對指定資料庫及資料表做操作(全部都要的話用 *)。 注意修改權限以後 一定要重新整理服務，或者重啟服務，重新整理服務。 12# 重新整理FLUSH PRIVILEGES;","link":"/2021/05/30/Mysql%20%E5%B8%B3%E8%99%9F%E7%AE%A1%E7%90%86/"},{"title":"PHP Closure(閉包、匿名函式)","text":"還不知道 PHP 有 Closure? 那你真的落伍了！ What is Closure?Closure: 用於表示匿名函式的 Class。 閉包減少了命名空間的混亂。也讓使用對象之間減少了相依性。 PHP5.3 開始支援匿名函式，讓一些需要彈性的場合更方便。 建立匿名函式注意: 賦予變數匿名函示，結尾大括號需要加結尾符號 ;。 12345$wellcome = function () { echo 'Hi, wellcome to my Home ';};$wellcome(); 我們可以透過 use 的宣告語法賦予匿名函式變數。注意: PHP 7.1 起，不能傳入此類變數：superglobals、 $this 或者和參數重名。 123456$houseCategory = 'villa';$wellcome = function () use ($houseCategory) { echo 'Hi, wellcome to my ' . $houseCategory . '.';};$wellcome(); 讓我們添加函式的指定參數 123456$houseCategory = 'villa';$wellcome = function ($name) use ($houseCategory) { echo 'Hi ' . $name . ', wellcome to my ' . $houseCategory . '.';};$wellcome('YoYo'); 會使用了之後，我們馬上用遞迴特性寫一個從 1 加總到指定數字的閉包吧。 123456789$fib = function ($n) use (&amp;$fib) { if ($n == 0) { return 0; } return $n + $fib($n - 1);};echo $fib(10); 小分享筆者很常在 某段邏輯前後的行為 需要被重複使用時，使用閉包。例如 sql 的 Transaction。此處程式碼為 Demo 用，無法直接執行。 12345678910111213141516171819202122232425262728293031323334353637/** * sqlTransaction * * @param \\Closure $closure * * @return mixed * @throws Exception */public function sqlTransaction(\\Closure $closure){ $db = \\Zend_Db_Table::getDefaultAdapter(); try{ $db-&gt;beginTransaction(); $re = $closure(); $db-&gt;commit(); return $re; }catch (Exception $e){ $db-&gt;rollBack(); throw new Exception($e-&gt;getMessage()); }}public function saveData(){ $model = $this-&gt;_model; $this-&gt;sqlTransaction(function () use ($data, $model) { // TODO 邏輯檢查 $model-&gt;update(data); // TODO 更新後行為 });} 小知識 閉包可利用遞迴特性，取代 foreach 效果。 閉包可用於邏輯處理中段需要客製化邏輯時。 再叫現代化的 PHP 框架(如 Laravel)中，閉包已經是被大量使用的技術。 有興趣可自行去翻閱 Laravel 原始碼。 現在，你學會了嗎！？","link":"/2020/10/25/PHP-Closure-%E9%96%89%E5%8C%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E5%BC%8F/"},{"title":"PHP Traits","text":"What is Traits?PHP 僅支援單一繼承: 子類別只能繼承單一物件。 若是一個類需要繼承多種行為怎麼辦呢？ Traits 解決了這個問題。 Traits 就是解決在單線繼承的限制下，讓程式碼能夠重複使用。並降低複雜度。 Traits 用於聲明可以在多個 class 中使用的屬性(property)/函式(function)，可以是抽象或是任何可視性(public、protect 、private)，甚至是靜態(abstract)屬性。 如何使用建立語法 1234trait TraitName { // some code...} 使用語法 1234class newClass { use TraitName;} Example123456789101112131415trait message{ function msg() { echo 'Welcome to my home.'; }}class Welcome{ use message;}$welcome = new Welcome();$welcome-&gt;msg(); 可以同時使用多個 12345678910111213141516171819202122232425trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msgQuestion() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion;}$welcome = new Welcome();$welcome-&gt;msg();echo '&lt;br/&gt;';$welcome-&gt;msgQuestion(); 若是名稱重複了呢？函式名稱重複是會造成錯誤的。 Fatal error: Trait method msg has not been applied, because there are collisions with other trait methods on... 需要在使用時就指定要用哪一個的方法。insteadof: 宣告前者為主要使用，要是有多個要全部涵蓋進去哦。 123456789101112131415161718192021222324252627282930313233trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}trait messageC{ function msg() { echo 'C'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion, messageC; }}$welcome = new Welcome();$welcome-&gt;msg(); 那被替代掉的函式都不能用了嗎？as: 替方法進行別名。 1234567891011121314151617181920212223242526trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion; messageQuestion::msg as msgQuestion; }}$welcome = new Welcome();$welcome-&gt;msgQuestion(); 小提醒: 就算有使用 as 進行別名，還是需要先使用 insteadof 解重名哦。","link":"/2020/09/23/PHP-Traits/"},{"title":"PHP 資訊安全 - 資料消毒","text":"荀子-性惡篇第二十三: 人之性惡，其善者僞也。 永遠不要相信任何來源不明的資料 不可信資料來源只要不是系統產出組合之資料，皆不可信。 如下: 12345678910$_GET$_POST$_REQUEST$_COOKIE$argvphp://stdinfile_get_contents()遠端資料庫遠端 API來自客戶端的資料 只要是外部來源資料都有可能是攻擊的源頭(XSS、CSRF等…) 怎麼說呢？您的網站允許使用 HTML 下評論，那將有可能受到 &lt;script&gt; 隱碼攻擊。 12345&lt;p&gt;This is good!!!&lt;/p&gt;&lt;script&gt;window.location.href='https://hank7891.github.io/';&lt;/script&gt; 您的登入帳號密碼被如此輸入，即會遭受 SQL Injection。 1234567891011account: ' OR 1=1 #password: 1234$account = $_GET['account']; // '' OR 1=1 #$password = $_GET['password'];$query = &quot;SELECT * FROM user WHERE account = '$account' AND password = '$password'&quot;;產生指令: SELECT * FROM user WHERE account = '' OR 1=1 #AND password = '1234'; 如此一來是不是令您毛骨悚然呢？ 所以呢？想要開發安全的 Web 應用程式，最重要的是正確掌握資料的用途狀態。 一般正規化消毒→一般處理用資料 例如：trim、magicquotesgpc、NUL、強制轉型、大小寫轉換、值域範圍檢查、白名單檢查、RegExp規則檢查 HTML輸出用消毒→HTML輸出用資料 例如：htmlspecialchars, strip_tags, htmlentities SQL輸出用消毒→SQL輸出用資料 例如：mysqlrealescape_string, addslashes – 最重要的是，這些用途的資料，應明確加以區別，不要混淆使用，一定要明確配合用途進行轉換。 所有資料的交換，都應使用一般處理用資料來進行，再依資料用途進行消毒，避免混用而造成遺忘或重複消毒。","link":"/2020/11/27/PHP-%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8-%E8%B3%87%E6%96%99%E6%B6%88%E6%AF%92/"},{"title":"PHP 輸出 Log 檔案","text":"用於輸出指定 PHP 檔案資訊。 廢話不多說，直接 Demo123456789101112131415161718192021222324//設定路徑目錄資訊$years = date('Y-m');$url = './log/' . $years . '/log.txt';//取出目錄路徑中目錄(不包括後面的檔案)$dir_name = dirname($url);//如果目錄不存在就建立if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true);}// 寫入資訊$msg = date('Y-m-d H:i:s');//開啟檔案資源通道，不存在則自動建立$fp = fopen($url,&quot;a&quot;);//寫入檔案fwrite($fp,var_export($msg,true).&quot;\\r\\n&quot;);//關閉資源通道fclose($fp);","link":"/2021/03/03/PHP%E8%BC%B8%E5%87%BALog%E6%AA%94%E6%A1%88/"},{"title":"Shell Script - 基礎","text":"將指令寫成檔案，即可讓乏味的重複性工作變得輕鬆。 將命令 Kernel 做事的指令寫成一個檔案，就叫做 Shell Script。 介紹Shell 是一種讓使用者可以和作業系統 Kernel（核心用來控制 CPU、記憶體、硬碟等硬體）互動溝通的橋樑。Shell Script 主要是使用在 Linux 和 MacOS 等 Unix-like 作業系統的自動化操作指令的程式語言。 Hello World建立 .sh 為副檔名的檔案，並賦予其執行權限。 12345678910# 建造檔案touch demo.sh# 賦予權限chmod -x demo.sh# 查看權限ls -l demo.sh# -rwxr-xr-x 實作 Hello World！ 將以下指令寫入指令檔。 1234# 宣告使用 /bin/bash#!/bin/bashecho &quot;Hello World.&quot;; 執行指令檔案 1./demo.sh 恭喜你已完成第一隻 Shell Script！ 變數定義變數時，開頭不用給予 $ 符號但使用變數時就需加上 $。並且注意 = 前後不能有空白。 1234567#!/bin/bashval=Hello Word.;val2=$val;echo $val; # 輸出結果: Hello World.echo $val2; # 輸出結果: Hello World. 雙引號 &quot;&quot; 內容中的特殊字元不會被忽略，而單引號 '' 中的所有特殊字元將被忽略。也可使用 \\ 跳脫符號將之後的一個字元將被視為普通字串。 1234567#!/bin/bashval=&quot;Hello World.&quot;;echo '$val'; # 輸出結果: $valecho &quot;$val&quot;; # 輸出結果: Hello World.echo &quot;\\$val&quot;; # 輸出結果: $val 也可使用花括弧${}來將變數包起來，可以了解變數的使用範圍。 12345#!/bin/bashval=&quot;Hello World.&quot;;echo ${$val}; # 輸出結果: Hello World. 運算運算符號需用 (()) 或 $(()) 包起來，前者在於在於會將計算結果回傳至原變數中(注意放入多個變數則不會運作)**，後者則是將計算結果回傳至指定變數中(可放置多個變數)**。 1234567891011#!/bin/bashval=1;val1=9;((val++)) # 此時 val = 2，注意不用加結尾符號val2=$((val*val1)); # 2 * 9 = 18echo $val; # 輸出 2echo $val1; # 輸出 9echo $val2; # 輸出 18 判斷式Shell 的判斷式有個潮爆了的特型，那就是結尾都是開頭的顛倒！Ex: if...fi、case ... esac… 先了解比對語法: 語法 代表意義 -eq/== 兩數值相等 (equal) -ne/!= 兩數值不等 (not equal) -gt n1 大於 n2 (greater than) -lt n1 小於 n2 (less than) -ge n1 大於等於 n2 (greater than or equal) -le n1 小於等於 n2 (less than or equal) if…fi判斷條件放置於[]中，前後須留白。 1234567891011121314#!/bin/bashx=1;y=2;if [ $x == $y ]; then echo 'x = y';elif [ $x -gt $y ]; then echo 'x &gt; y';elif [ $x -lt $y ]; then echo 'x &lt; y';else echo '有本事把我用出來';fi case…esac123456789101112131415#!/bin/bashlanguage='TW';case ${language} in 'TW') echo '中文'; ;; 'EN') echo '英文'; ;; *) echo '看不懂'; ;;esac 迴圈跟大多數語言一樣，均可用 continue(省略後續)、break(結束迴圈)。若是不小心進入無窮迴圈，可用 ^C 結束程式。 for12345#!/bin/bashfor loop in 1 2 3; do echo $loop;done while條件成立會持續執行。 12345678910#!/bin/bashcount=1;# 1 數到 9 (條件小於 10 執行)while [ $count -lt 10 ]; do echo $count; ((count++)) sleep 0.5;done until條件不成立會持續執行。 12345678910#!/bin/bashcount=10;# 10 數到 1 (條件不小於 1 執行)until [ $count -lt 1 ]; do echo $count; ((count--)) sleep 0.5;done 特殊變數可以在執行命令檔案時，帶入參數並且應用。 使用方式: 指令 意義 $0 目前的檔案檔名 $n n 從 1 開始，代表第幾個參數 $# 傳遞到程式或函式目前有幾個參數 $* 傳遞到程式或函式所有參數 $@ 類似 $* 但是在被雙引號包含時有些許不同 $? 上一個指令退出狀態或是函式的返回值 $$ 目前 process PID 1./demo.sh A B 123456789#!/bin/bashecho &quot;$0&quot;;echo &quot;$1&quot;;echo &quot;$#&quot;;echo &quot;$*&quot;;echo &quot;$@&quot;;echo &quot;$?&quot;;echo &quot;$$&quot;; 執行結果就由各位自行去看囉～ 總結此篇文章僅講述一些基本的語法應用，有程式底子的人在學 Shell Script 並不會太困難。 Shell Script 常用於系統管理、自動化操作檔案、自動化重複的指令碼、分析 log 等文件檔案、列印呈現我們想要的資料等… 在熟悉基礎後就可以組合出想要的邏輯進而達到有效率的工作行為。","link":"/2021/07/22/Shell%20Script-%E5%9F%BA%E7%A4%8E/"},{"title":"Solid","text":"其實網路上對SOLID的探討及見解文章已經多不勝數。筆者在此僅記錄自身見解與歷程。 若對該原則理解有誤，請不吝指教。 SOLID? 在程式設計的領域中，SOLID指物件導向編成和物件導向設計的五個基本原則。 當這些原則一起被應用時，可以使程式設計師開發一個容易擴充及維護的系統。 SOLID所包含的原則是通過引發編程者進行軟體原始碼代碼重構的代碼異味清掃。從而使軟體清晰可讀及具可擴展性。 SOLID被典型的應用在測試驅動開發上，且是敏捷開發及自適應軟體開發的基本原則重要組成部分。 S: Single responsibility principle(SRP) 單一職責定義: 1一個類別(class)/方法(method)只能負責一個職責 如果一個類別做了兩件職責，就必須拆成兩個類別。 當類別包含複數職責時，則其內聚力越低。 當類別職責越單純且清楚，則其內聚力越高。 舉例: 如果汽車與飛機皆為交通工具而實作於同一個類別(super obj)中，汽車行為模式為 run 而飛機行為模式為 fly。那該類別內部邏輯會變得雜亂且難以維護。 若將汽車與飛機個別實作，各自物件只要管理自己的權責。即可提高內聚。而特定邏輯修改時只要到對應物件內做調整，也降低了維護的難易度。 結論: 一個 class/method 只做一件事。 遵守 SPR 可為程式提高內聚。 Open/close principle(OCP) 開放/封閉原則定義: 1程式在擴充新功能時，不更動原程式碼或者僅以最小幅度修改程式碼的開發方式。 系統實作完若遇到新需求，必須回頭調整原本做好的程式代碼。而只要修改舊的代碼就可能造成不良副作用 #1。應以最小的幅度來修改已存在的程式碼（甚至不修改)才是最佳的情況。 OCP 使系統保有彈性，可以擴充新功能。若有新需求只要進行新增，而不用修改到舊有程式碼(對修改封閉，對新增開放)。進而杜絕不良副作用的產生。 OCP 只是一個原則，讓程式變得靈活的代價是需要花費額外的時間與精力將程式引入新的抽象層，還會增加程式的複雜度。所以 OCP 原則只適合被套用於經常變更的地方！ (#1)不良副作用: 修改程式內碼造成其他使用的該邏輯的地方產生錯誤，即大家口中的改 A 壞 B。 舉例: 設計車子時，因單一職責(SPR)而對車上零件(車燈、輪胎、引擎)進行模組化。若此時若想將一般輪胎換成雪胎。而去修改一般輪胎的模組(物件)內容，可能造成其他使用該物件的邏輯錯誤。 若遵守 OCP 原則，僅對輪胎新增雪胎模組，在車子內部進行替換組合。則只需新增還不需要修改。拒絕了改 A 壞 B的情況產生。 結論: 只有經常變更的地方需要使用 OCP 原則。 系統對新增開放，修改封閉。 L: Liskov substitution principle(LSP) Liskov替換定義: 12Subtypes must be substitutable for their base types.所有子類別都可以代理父類別的工作。 里氏替換原則原則要能夠成立，介面(interface)/抽象方法(Abstract method) 就必須要遵守定義去實做。 子類別需兌現對父類別的承諾，遵照父類別設計開發。 作為子類別的方法必須和他們父類別的方法操作一致，子類別中可以擁有父類別沒有的特殊功能，但是繼承的方法，功能應該兩者一致的。 子類不只是實現父類別的方法，而且必須名符其實，否則會發生無法預料的事情。 舉例: 雪胎及一般輪胎皆繼承輪胎模組(父類別)，而組裝者可由方法取得材質(function)取得輪胎材質來判斷是否適合組裝。若雪胎擅自更改回傳值為適用地形。就會造成組裝者誤判而產生無法逾期之錯誤。 若遵守 LSP 原則，取得材質(function)方法應該遵循輪胎模組(父類別)設計結構去回傳正確值。即可避免程式的行為變得不可預測。 結論: 子類別必須遵從父類別或介面的設計理念去實作方法。 LSP 是實現 OCP 原則的重要方式，只有當子類別能夠完全替代它們的父類別類時，使用父類別的函數才能夠被安全的重用。 I: Interface Segregation Principle(ISP) 介面隔離定義: 12Clients should not be forced to depend upon interfaces that they don’t use.介面不應該強迫 Client 依賴於它們用不到的方法。 12The dependency of one class to another one should depend on the smallest possible interface.類別之間的相依關係應該建立在最小的介面上 類別與類別之間的關係，應只依賴彼此需要的最少介面，介面不能太肥，應該要細化。 介面的目的都是提供一個讓 Client 端可以使用我們開發模組的管道。 介面處於應用程式與模組之間、或是專案與模組之間，這種關係就如同第三方套件提供服務 API 給一個網站使用。 舉例: 跑車與玩具車皆繼承汽車模組(父類別)，而汽車模組(父類別)存在一方法跑(function)。但玩具車並不具備跑(function)這個行為，若是空實作則違反 LSP 原則。 應該設計兩介面(interface):模型車(interfece)與實車(interface)。而於實車(interface)內部宣告跑(function)方法，再由跑車與玩具車個別去實作對應的介面(interface)。 結論: ISP 可降低商業邏輯（低階模組）與 Client 之間的耦合。 設計模組時，要以 Client 需求的角度建立介面，且避免設計龐多功能的單一介面。 設計介面(interface)的時候，應該考慮單一職責原則，把有關聯的方法放在一起，分割出多個單一功能的介面。 D: Dependency Inversion Principle(DIP) 依賴反轉定義: 12High-level modules should not depend on low-level modules. Both should depend on abstractions.高階模組不應該依賴於低階模組，兩者都該依賴抽象。 12Abstractions should not depend on details.抽象不應該依賴細節。 12Details should depend on abstractions.低階模組的實作內容應該依照抽象的定義去實作。 高階與低階，是相對關係，其實也就是 呼叫者 (Caller) 與 **被呼叫者 (Callee)**。 ￼高階模組直接依賴低階模組，則為高耦合。 不應該讓任何東西直接依賴低階模組。 DIP 由 DI(注入) 與 IOC(控制反轉) 實作。目的為解除耦合性(解偶)。 舉例: 實作汽車時需組裝零件，此時若將零件寫死於汽車中。若其中一項零件停產了或要更換。則需到汽車中修改既有內碼(違反 OCP)。 以輪胎為例，汽車有內碼使用 一般輪胎。而一般輪胎剛好停產或廢棄了。那汽車即會出錯。若是要修改還需要到汽車內碼中將使用 一般輪胎改成使用 新的一般輪胎。 若依照 DIP 設計。將輪胎抽離於組裝者取得並組裝於車上。舉例來說汽車-&gt;組裝輪胎(一般輪胎)。依上述情境若一般輪胎出事了，組裝者只要從外部替換輪胎汽車-&gt;組裝輪胎(新的一般輪胎)。則不用更動汽車程式內碼，汽車與輪胎之間也不具備耦合性。 結論: 介面(interface)應由高階模組去制定規範。 使用介面(interface)確保低階模組開發正確性。 遵守 DIP 可大大降低物件之間的耦合性(解偶)。 依賴反轉原則可以幫助我們遵守其他原則，遵守依賴反轉的過程中會： 拆散類別的職責(SRP)。 更容易達成 OCP。 避免父子類別沒有依照介面的定義實作(LSP)。 拆散介面的職責(ISP)。 ——————-工程師最怕聽到的就是程式又要改。而SOLID原則是前人經過無數經驗統整出使程式具備容易維護且具可擴充性質。讓之後在更動程式或擴充需求時能降低修改既有程式難易度。雖說SOLID原則能使程式品質有實質的躍升，但還是得注意別陷入過度設計。 參考網址物件導向程式設計基本原則 - SOLID 【筆記】物件導向設計 : SOLID 介紹","link":"/2019/11/26/Solid/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/27/hello-world/"},{"title":"正規表示式 - Regular Expression","text":"正規表示式 (Regular Expression)能為你檢查是否為全英文字串！ 很專業！ 正規表示式 (Regular Expression)能為你檢查是否為指定結構字串！ 很貼心！ 正規表示式 (Regular Expression)能為你找出複雜性組成字串！ 很厲害！ What is it?Regular Expression 又稱正規表達式、正規表示法、規則運算式、常規表示法。是一門電腦科學，是用來比對字串是不是有符合正確的格式。 語法簡單，功能強大，最重要的是！幾乎已知的語言都有支援他。包誇了各大編譯器皆有支援。 開始之前讓我們擁有一個實用的線上工具 regex101。 您可以在 TEST STRING 的地方輸入 focus，在於 REGULAR EXPRESS 的地方輸入 focus 或其中一字元都行(注意大小寫)。是否被選起來了呢！ 下面的教學皆可直接扔進線上工具內使用哦！ 注意: 正規表示法使用時前後須由 / 包起來(/a/)，但該工具 REGULAR EXPRESS 中輸入時不用。 語法字元 12a: a字元.: 所有可能的字元(字母、數字或符號)。 RegExp 說明 範例 /a/ 含有字元 a a , ab , ba , bbacc /./ 任意單一字元 a , ab , ba , bbccc , 哈囉 /a./ 含有字元 a 且後面接任意單一字元 a1 , ab , a囉 次數 12345678*: 比對前一個字串 0 次或是多次。?: 比對前一個字串或是不比對。+: + 跟 * 類似，差別在於它至少要與前一個字比對一次或以上。{n,m}: 指定出現次數，n 為最小次數 m 為最大次數。{2}: 2 次。{2,}: 2 次以上。{2,5}: 2 到 5 次。 RegExp 說明 範例 /ba*c/ bc 字元中間，a 字元出現 0 次或是多次。 bc , bac , baaac /ba?c/ bc 字元中間，a 字元出現 0 次或一次。 bc , bac /ba+c/ bc 字元中間，a 字元出現 0 次或一次。 bac , baaac /ba{2}c/ bc 字元中間，a 字元出現 2 次。 baac /ba{2,}c/ bc 字元中間，a 字元出現 2 次以上。 baac , baaac /ba{2,5}c/ bc 字元中間，a 字元出現 2 - 5 次。 baac , baaaaac 條件 1234^: 字串開頭。$: 字串結尾。|: 前字串或者後字串。\\: 跳脫特殊字元。 若要比對正規表示式內部特殊字元(*?+{}[] 等...)，需用反斜線來跳脫這些特殊字元。 RegExp 說明 範例 /^ab/ ab 開頭字串。 ab , abc /ab$/ ab 結尾字串。 ab , cab /acc bcc/ acc 字串或 bcc 字串。 /a\\*/ a*字串。 a* , aa* , a*a 多字元篩選 123[ ] : [] 內所包含字元。[^] : 不存在 [] 內的任何字元。[-] : 連號字元(0-9 a-z A-Z)。 RegExp 說明 範例 /[abc]/ abc 任一字串。 abc , ade , bde , cde /[^abc]/ 非 abc 任一字串。 def , ggg , ddd /[0-9]/ 數字 0 - 9 0123456789 , a0b , 9a8n 在 [ ] 後面接上 {n}，則會取得 [] 中指定數量組合(不分順序)。 1EX: [abc]{2} : `ab` , `cb` , 'ac' 特殊字元 123456\\d: 任何數字字元，等同 [0-9]\\D: 任何非數字字元，等同 [^0-9]\\w: 任何數字字母底線，等同 [A-Za-z0-9_]\\W: 任何非數字字母底線，等同 [^A-Za-z0-9_]\\s: 任何空白字元(空白,換行,tab)，等同 [ \\f\\n\\r\\t\\v]\\S: 任何非空白字元(空白,換行,tab)，等同 [^ \\f\\n\\r\\t\\v] 實例12345678西元生日: 四個數字開頭 - 兩個數字 - 兩個數字結尾RegExp: /^\\d{4}-\\d{2}-\\d{2}$/身分證字號: 英文字母開頭(大寫) 九個數字RegExp: /^[A-Z]\\d{9}$/手機號碼: 國碼開頭(09) 八個數字RegExp: /^09\\d{8}$/ 同場加映Regex matching line not containing the string不包含指定的字元！ 1RegExp: ^((?!YoYo).)*$ Hello YoYo! Hello Hank! 保留差異字元取代 筆者覺得這個超重要，大家一定要會。 在正規表示式中被 () 所選起來的參數可以被保留至變數中。保留變數會由 $1 $2 $3 所使用。 12345678910# 一段句子中，若只替換問候語而保留人名。Hello, YoYo!Hello, Hank!搜尋 RegExp: /Hello, (.*)!/取代 RegExp: /Shit, $1!/# 輸出結果Shit, YoYo!Shit, Hank! 什麼？ 你問我這有什麼用？筆者遇到的問題是，因為語言版本的關係。要將程式內的變數使用 {} 替換為 []; 12345678Ex:$str{0};$str{1};$str{2};$str{3};$str{'name'};$str{'email'}; 總不可能要我一個一個去替換吧！！這邊考考各位，要怎麼一組替代語法將 $str{} 替換成 $str[] ！筆者的答案在下方哦 ※1。 結語Regular Expression 是非常好用的工具，且應用範圍很廣。編譯器對專案全區域搜尋、各程式語言內部使用設置是資料庫應用都可以做出很好的工作效率。 這篇只是筆者對基本 Regular Expression 的介紹。大家能在利用網路資源，進行更深入的學習。 ※1: 12搜尋 RegExp: \\$str\\{([^\\}]*)\\}取代 RegExp: \\$str\\[$1\\]","link":"/2021/02/23/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F%20(Regular%20Expression)/"},{"title":"重新擁抱程式設計 - 淺談 JavaScript","text":"世界上最流行的程式語言之一又號稱世界上被誤解最深的程式語言。 世界上最被人誤解的程式語言 - JavaScriptJavaScript 又名 Mocha、LiveScript、JScript 又或者叫 ECMAScript。 原因如下: The Name 許多人會將 JavaScript 當成是 Java 的子程式、也因為 script 這個字眼，而認為它不是一個真正的程式語言。 Moving Target 初版的 JS 非常的粗糙，沒有例外處理、內部函式、以及繼承的概念。即便現在的版本已經是一個物件導向的程式語言，但初期的壞印象仍讓許多人有既定的印象。 Design Errors JS 與其他語言一樣，有許多設計上的錯誤，例如 + 號同時代表了字串的串接及數值的相加、或者是 with 的使用、Regular Expression 的寫法、保留字的使用太過嚴格，這些設計上的錯誤都讓人在開發過程中產生疑惑。 令人驚訝的是，ECMA 組織似乎沒有要修正這些問題。 Bad Implementations 較早期的錯誤撰寫方式存在許多嚴重的錯誤。更糟糕的是，這些實現被嵌入到令人毛骨悚然的錯誤 Web 瀏覽器中。 Amateurs 通常編寫 Javascript 都是不具有程式語言背景的工程師，寫出來的東西自然就給人奇差無比的觀感。 Bad Books 書籍及文件所提供的錯誤觀念。 Substandard Standard 不夠標準的規範，ECMA 所發布的規格質量極差。這很難閱讀，也很難理解。這是造成 Bad Book 問題的原因，因為作者無法使用標准文檔來提高自己對這種語言的理解。 JavaScript 的名字由來最開始這門語言取名叫「Mocha」，1995 年 9 月 Netscape 宣布要在LiveWire (伺服器端環境) 啟用某個程式語言，於是這門程式語言就被叫做「LiveScript」。 同年 12 月基於行銷考量，為了讓這門語言搭上 Java 這個程式語言「熱詞」，因此將其臨時改名為 JavaScript，日後這成為大眾對這門語言有諸多誤解的原因之一。 所以，Java 跟 JavaScript 到底有沒有關係？除了名字之外，根本沒有關係。之所以名字會很像，只是單純 Netscape 想要蹭熱度罷了。 JavaScript 基礎篇[1]: 變數與資料型別&gt;&gt;&gt;","link":"/2020/12/01/%E9%87%8D%E6%96%B0%E6%93%81%E6%8A%B1%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%20-%20%E6%B7%BA%E8%AB%87%20JavaScript/"},{"title":"HEXO 移機教學","text":"hexo 重新建置環境。 hexo 更換電腦。 小弟剛好換新電腦，在此紀錄移植 hexo 編寫環境紀錄。 檢查編寫環境12345678# 檢查是否有安裝 git$ git --version# 檢查是否安裝 node.js$ node -v# 檢查是否有安裝 hexo$ hexo -v 若環境沒安裝完全，且忘記怎麼裝了: 點我 備份開發環境備份舊電腦的開發文件 新開發環境將備份檔案放置新電腦後，進到對應資料夾，並用 npm 建置原始檔案編譯。 1234567$ cd blog# npm 建立編譯檔$ npm install# 下載 git 工具$ npm install hexo-deployer-git --save 執行看看，看看在本機看看網站有沒有各種毀滅。 12# 可以透過本機的 http://localhost:4000 查看結果$ hexo s --debug 完成後就可以開始快樂得文章編寫拉!!","link":"/2021/09/17/Hexo-%E7%A7%BB%E6%A9%9F%E6%95%99%E5%AD%B8/"},{"title":"設計模式 - 工廠模式(簡單工廠、工廠方法、抽象工廠)","text":"簡單工廠模式 工廠模式 抽象工廠模式 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹工廠模式重點在於情境複雜度度來針對代碼提取及封裝的行為，可以的達到高內聚、低耦合的效果。 工廠模式又細分為以下三種: 簡單工廠模式。 工廠方法模式。 抽象工廠模式。 簡單工廠模式又稱靜態工廠，可以用於較簡單邏輯的業務需求。嚴格來說簡單工廠模式不是一種設計模式，更像是一種開發習慣。 定義透過一個類別來創建其他類別的實例，被創建的實例通常要有共同的父類別。 組成 工廠角色：負責依照內部邏輯返回創建的實例。 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 範例抽象產品角色 1234abstract class Academy{ abstract function announce();} 具體產品角色 123456789101112131415class Gryffindor extends Academy{ public function announce() { echo '葛萊芬多！ &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce() { echo '史萊哲林！ &lt;br/&gt;'; }} 工廠角色 123456789101112131415161718class AcademyFactory{ public static function createAcademy($academy) { switch ($academy) { case 'Gryffindor': return new Gryffindor(); case 'Slytherin': return new Slytherin(); default: echo '無此學院'; return null; } }} 使用工廠 12345# 格萊芬多宣示AcademyFactory::createAcademy('Gryffindor')-&gt;announce();# 史萊哲林宣示AcademyFactory::createAcademy('Slytherin')-&gt;announce(); 輸出結果 12葛萊芬多！史萊哲林！ 討論 該模式依照邏輯判斷實作何種產品的實例，客戶端可以免除直接創建產品的責任。 但若是新增了產品(霍格華滋不單只有兩個學院)，必然修改工廠邏輯，此行為直接違反了開放封閉原則，且在產品過多的情況下，會造成邏輯複雜難以維護的問題。 工廠方法模式屬於『創建型模式』。 定義由父類別定義一個建立物件的介面(工廠方法)，再由實作的次類別(工廠類別)去實作實體化的動作，工廠方法是一個抽象的方法。 組成 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 工廠父類別：內含用以實體化的產品的抽象方法。 工廠子類別：實作產生物件的方法。 範例 抽象產品角色及具體產品角色 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Academy{ abstract public function announce(): string; abstract public function feature(): string; abstract public function mascot(): string;}class Gryffindor extends Academy{ public function announce(): string { return '葛萊芬多！ &lt;br/&gt;'; } public function feature(): string { return '強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。 &lt;br/&gt;'; } public function mascot(): string { return '獅。 &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce(): string { return '史萊哲林！ &lt;br/&gt;'; } public function feature(): string { return '有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。 &lt;br/&gt;'; } public function mascot(): string { return '蛇。 &lt;br/&gt;'; }} 工廠父類別 1234abstract class AcademyFactory{ abstract public function introduceAcadmy();} 工廠子類別 123456789101112131415161718192021class GryffindorFactor extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Gryffindor(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); }}class SlytherinFactory extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Slytherin(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); }} 分類帽 123456789echo '哈利波特適合葛萊芬多！ &lt;/br&gt;';$selectAcadmy = new GryffindorFactor();$selectAcadmy-&gt;introduceAcadmy();echo '&lt;/br&gt;';echo '馬份似乎比較適合史萊哲林！ &lt;/br&gt;';$selectAcadmy = new SlytherinFactory();$selectAcadmy-&gt;introduceAcadmy(); 輸出結果 123456789哈利波特適合葛萊芬多！學院：葛萊芬多！特質：強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。代表物：獅。馬份似乎比較適合史萊哲林！學院：史萊哲林！特質：有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。代表物：蛇。 討論 因為工廠模式隱藏了內部實作細節，客戶端只要注重於正確工廠的使用，這使得整個設計符合了單一職責，提高了系統內聚性。 若今日要添加兩個學院(霍格華滋有四大學院)，只要添加對應工廠即可，這樣就不會更改到原有的邏輯，也符合了開放封閉原則。 但由於將實作細節封裝進工廠內部，會導致系統結構複雜化，後續人員的學習曲線會跟著提高。更糟糕的是若設計上有所失誤，會大大提升功能的擴充性及維護性的難度。 抽象工廠抽象工廠注重的是各種不同的產品得實作與組合，父類別會定義多個抽象物件讓次類別(工廠類別)去實作各個實體化的動作。像是汽車的內裝(不同廠牌的音響)、冒險者的武器(長劍或弓)或是家電的零件(面板來源)等… 定義由父類別定義多個建立物件的介面(工廠方法)**，再由實作的次類別(工廠類別)去實作各個實體化的組裝動作**。 組成 抽象產品角色：一般是讓具體產品繼承的父類或者實現的接口。由接口或者抽象類來實現。 具體產品角色：工廠類所創建的對象就是此角色的實例。 工廠父類別：內含用以實體化的產品的抽象方法。 工廠子類別：實作產生物件的方法。 範例抽象產品角色及具體產品角色(學院，此時多了寶物而未裝備) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class Academy{ protected string $treasure=''; abstract public function announce(): string; abstract public function feature(): string; abstract public function mascot(): string; public function setTreasure($setTreasure) { $this-&gt;treasure = $setTreasure; } public function showTreasure(): string { if (trim($this-&gt;treasure) == '') { return '糟糕，我沒拿到寶物'; } return $this-&gt;treasure; }}class Gryffindor extends Academy{ public function announce(): string { return '葛萊芬多！ &lt;br/&gt;'; } public function feature(): string { return '強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。 &lt;br/&gt;'; } public function mascot(): string { return '獅。 &lt;br/&gt;'; }}class Slytherin extends Academy{ public function announce(): string { return '史萊哲林！ &lt;br/&gt;'; } public function feature(): string { return '有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。 &lt;br/&gt;'; } public function mascot(): string { return '蛇。 &lt;br/&gt;'; }} 抽象產品角色及具體產品角色(寶物，待工廠實作組裝給學院生) 123456789101112131415161718192021abstract class Treasure{ abstract public function equipTreasure(): string;}class GryffindorTreasure extends Treasure{ public function equipTreasure(): string { return '格萊芬多寶劍！'; }}class SlytherinTreasure extends Treasure{ public function equipTreasure(): string { return '史萊哲林小金匣！'; }} 工廠(創建學院生並給予寶物) 12345678910111213141516171819202122232425262728293031323334abstract class AcademyFactory{ abstract public function introduceAcadmy();}class GryffindorFactor extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Gryffindor(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); $treasure = new GryffindorTreasure(); $acadmy-&gt;setTreasure($treasure-&gt;equipTreasure()); return $acadmy; }}class SlytherinFactory extends AcademyFactory{ public function introduceAcadmy() { $acadmy = new Slytherin(); echo '學院：' . $acadmy-&gt;announce(); echo '特質：' . $acadmy-&gt;feature(); echo '代表物：' . $acadmy-&gt;mascot(); $treasure = new SlytherinTreasure(); $acadmy-&gt;setTreasure($treasure-&gt;equipTreasure()); return $acadmy; }} 分類帽(分派學生，且學生高興地舉起手中的寶物) 1234567891011echo '哈利波特適合葛萊芬多！ &lt;/br&gt;';$selectAcadmy = new GryffindorFactor();$potter = $selectAcadmy-&gt;introduceAcadmy();echo '哈利波特：我手上握有' . $potter-&gt;showTreasure() . '&lt;/br&gt;';echo '&lt;/br&gt;';echo '馬份似乎比較適合史萊哲林！ &lt;/br&gt;';$selectAcadmy = new SlytherinFactory();$malfoy = $selectAcadmy-&gt;introduceAcadmy();echo '馬份：我手上握有' . $malfoy-&gt;showTreasure() . '&lt;/br&gt;'; 輸出結果 1234567891011哈利波特適合葛萊芬多！學院：葛萊芬多！特質：強調勇氣的特質，還有「膽識、氣魄和豪爽」，注重榮譽與騎士精神。代表物：獅。哈利波特：我手上握有格萊芬多寶劍！馬份似乎比較適合史萊哲林！學院：史萊哲林！特質：有野心、精明、狡猾，有很強的領導力，足智多謀，審時度勢，並且追求成就。代表物：蛇。馬份：我手上握有史萊哲林小金匣！ 討論 由工廠去組裝各個實作產品，讓各部件的組合更具重用性及靈活性。充分達到高內聚、低耦合的設計目的。 增加新的具體工廠和產品族很方便，不需要修改已有的系統，非常符合開放封閉原則。 因為間有組合的關係，要修改結構是相當麻煩的。","link":"/2021/09/27/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F(%E7%B0%A1%E5%96%AE%E5%B7%A5%E5%BB%A0%E3%80%81%E5%B7%A5%E5%BB%A0%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0)/"},{"title":"AES 資料加密","text":"進階加密標準（英語：Advanced Encryption Standard，縮寫：AES），在密碼學中又稱 Rijndael 加密法，是美國聯邦政府採用的一種區塊加密標準。 加密方式比對 對稱加密：採用單密鑰的加密方法，同一個密鑰可以同時用來加密和解密。常用的對稱加密算法有 DES，3DES，AES 等。 非對稱加密，需要兩個密鑰來進行加密和解密，這兩個密鑰是公開密鑰（public key，簡稱公鑰）和私有密鑰（private key，簡稱私鑰）。常用的非對稱加密算法有 RSA，Elgamal，ECC 等。 簡單做一下兩者的比對: 功能特性 對稱加密 非對稱加密 密鑰特徵 加密方和解密方使用同一個密鑰 加密方和解密方使用不同的密鑰 加密效率 效率高，速度快 速度慢 密鑰安全性 傳輸過程中容易洩漏 安全性高 設計思維 安全性(Security) ：演算法足夠強，抗攻擊。 經濟性(Efficiency) ： 演算法運算效率高。 金鑰捷變(Key Agility) ：更改金鑰所引入的損失儘量小，即最小消耗的金鑰擴充套件演算法。 適應性 (Versatility) ：適用於不同的CPU架構，軟體或硬件平臺的實現。 設計簡單(Simplicity) ：輪函式的設計精簡，只是多輪迭代。 評判要求NIST在徵集演算法的時候就提出了幾項硬性要求： 分組加密演算法：支援 128 位分組大小，128/192/256 位金鑰 。 安全性不低於 3DES，但實施與執行要比 3DES 的更高效 。 優化過的 ANSI C 的實現程式碼 KAT(Known-Answer tests) 及 MCT(Monte Carlo Tests) 測試及驗證 。 軟體及硬體實現的便捷 。 可抵禦已知攻擊。 設計準則 混淆 (Confusion) 最大限度地複雜化密文、明文與金鑰之間的關係，通常用非線性變換演算法達到最大化的混淆。 擴散 (Diffusion) 明文或金鑰每變動一位將最大化地影響密文中的位數，通常採用線性變換演算法達到最大化的擴散。 實作原理AES算法主要有四種操作處理，分別是輪 密鑰加層(Add Round Key) 、 字節代換層(SubBytes) 、 行位移層(Shift Rows) 、 列混淆層(Mix Columns) 。AES加密的過程，並不是明文和密鑰簡單運算一下。 在上面的幾個步驟中，我們是對輸入對數據進行混淆。 AddRoundKey每執行一次叫做一輪加密，這一步會執行多次。簡單來說就是把密鑰和混淆後的結果進行 xor 運算，但在每一輪使用的密鑰都是根據上一輪的密鑰變換而來的。 看一下動畫： (圖片來源) 加密模式AES只能對固定長度的數據進行加密，對於不定長的數據，我們需要把它切分成若干定長的數據，再進行加密解密，這就是我們常說的分組加密。分組加密有 ECB、CBC、CFB、OFB 這幾種加密模式，我們介紹一下 ECB 模式和 CBC 模式。 ECB：最簡單的塊密碼加密模式，加密前根據加密塊大小（如AES為128位）分成若干塊，之後將每塊使用相同的密鑰單獨加密，解密同理。具體見圖： ECB 模式由於每塊數據的加密是獨立的，所以可以分塊進行並行加密或者解密。它的缺點是相同的明文塊會被加密成相同的密文塊，所以這種方法在某些條件下安全性相對不是很高。 CBC：每個待加密的密碼塊在加密前會先與前一個密碼塊的密文異或然後再用加密器加密，第一個明文塊與一個叫初始化向量IV的數據塊異或。具體見下圖： 完成加密或解密後會更新初始化向量IV，CBC模式安全性更高，但由於對每個數據塊的加密依賴前一個數據塊的加密，所以加密是無法並行的。 PHP 實作12345678910111213141516$sourceKey = &quot;TestKey&quot;;$sourceIv = &quot;TestIV&quot;;$cypher = &quot;AES-256-CBC&quot;;$options = OPENSSL_RAW_DATA; //OPENSSL_RAW_DATA、OPENSSL_ZERO_PADDING$key = substr(hash(&quot;sha256&quot;, $sourceKey), 0, 32);$iv = substr(hash('sha256', $sourceIv), 0, 16);# 加密$e = base64_encode(openssl_encrypt('YoYoLin', $cypher, $key, $options, $iv));# 解密$d = openssl_decrypt(base64_decode($e), $cypher, $key, $options, $iv);echo $e;echo '&lt;/br&gt;';echo $d; Mysql 實作12345678# 設置模式SET block_encryption_mode = 'aes-256-cbc';# 輸出加密字串 (str, key, iv)SELECT TO_BASE64(AES_ENCRYPT('我是小飛俠', 'd713884fffad4dc8dd5da087efde2287', 'a49eed4cb8bddb3a')) AS '加密字符串'# 輸出解密字串 (str, key, iv)SELECT AES_DECRYPT(FROM_BASE64(&quot;IrNseqV16ZDYZWNiI4fAcA==&quot;),'d713884fffad4dc8dd5da087efde2287', 'a49eed4cb8bddb3a') AS '解密字符串'","link":"/2021/10/01/AES%20%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86/"},{"title":"PHP - Aes 加密上傳檔案","text":"手把手 PHP 針對上傳檔案做 AES 加解密教學。 各位看倌，若是對 Aes 不太了解可以看這篇呦。 事前準備需要各位看倌，請先幫我準備好 PHP 執行環境並建立同下圖的資料結構。 boss_o.jpeg 是一張由 Google 上抓取的圖片，作為範例檔案使用。 decode 放置解密後資料位置。 encrypt 放置加密後資料位置。 index.php 主程式，實作程式內部邏輯。 來點簡單的檔案上傳 1234567891011121314151617181920&lt;?php# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; # 檔案位置 $dest = 'encrypt/' . $_FILES['file']['name']; # 將檔案移至指定位置 move_uploaded_file($file, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 只是一個簡單的檔案上傳邏輯，確保上傳檔案有成功放至資料夾 encrypt 內。 將上傳的檔案做加密的動作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php# 加密function encrypt($key, $payload){ $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('aes-256-cbc')); $encrypted = openssl_encrypt($payload, 'aes-256-cbc', $key, 0, $iv); return base64_encode($encrypted . '::' . $iv);}# 寫入檔案function setFile($msg, $dest){ //取出目錄路徑中目錄(不包括後面的檔案) $dir_name = dirname($dest); //如果目錄不存在就建立 if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true); } //開啟檔案資源通道，不存在則自動建立 $fp = fopen($dest, &quot;w&quot;); //寫入檔案 fwrite($fp, $msg); //關閉資源通道 fclose($fp);}# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; $dest = 'encrypt/' . $_FILES['file']['name']; $e = encrypt('testKey', file_get_contents($file)); setFile($e, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 此處將上傳的檔案內容取出做 AES 加密的行為，再將加密資料存回檔案。 透過 openssl_encrypt 加密內部資料，再由 base64_encode 將加密資料進行編碼以便儲存。 此處筆者將 iv 值放置加密資料後面，方便解密。 setFile 是簡單的建立檔案並寫入內容邏輯。 將加密過的檔案做解密的動作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php# 解密function decode($key, $garble){ list($encrypted_data, $iv) = explode('::', base64_decode($garble), 2); return openssl_decrypt($encrypted_data, 'aes-256-cbc', $key, 0, $iv);}# 寫入檔案function setFile($msg, $dest){ //取出目錄路徑中目錄(不包括後面的檔案) $dir_name = dirname($dest); //如果目錄不存在就建立 if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true); } //開啟檔案資源通道，不存在則自動建立 $fp = fopen($dest, &quot;w&quot;); //寫入檔案 fwrite($fp, $msg); //關閉資源通道 fclose($fp);}# 檔案上傳邏輯if ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;&amp; isset($_FILES['file']) &amp;&amp; $_FILES['file']['error'] == 0) { $file = $_FILES['file']['tmp_name']; $dest = 'decode/' . $_FILES['file']['name']; $d = decode('testKey', file_get_contents($file)); setFile($d, $dest); echo '上傳成功' . '&lt;/br&gt;';}?&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; 上傳加密後的檔案，並透過 base64_decode 及 openssl_decrypt 逆向將檔案解密出來。若正確解密的話能在資料夾 decode 內看到解密後的檔案。 注意加密及解密時的 Key 要是一至的。 由於 iv 值 被存於加密後檔案後面，實作上只要管控好 Key 就好。 後話 由於 file_get_contents 是將檔案內容全部存於記憶體內，所以要注意檔案大小及 PHP 開放記憶體是否充足。 加解密 key 及 iv 數值保管，可由看倌們自行決定。 上述為普通的加解密邏輯實作及介紹，懶人包可直接抓取 CODE。","link":"/2021/10/08/PHP-Aes%E5%8A%A0%E5%AF%86%E4%B8%8A%E5%82%B3%E6%AA%94%E6%A1%88/"},{"title":"設計模式 - 策略模式","text":"沒有戰略的企業就像一艘沒有舵的船，只會在原地轉圈。 Without a strategy, an organization is like a ship without a rudder, going around in circles. – Joel Ross 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹策略模式屬於行為模式，依照不同的情境制定不同的策略(行為)，策略(行為)之間可以互相替換而不受影響。像是行軍打仗時將軍的戰爭策略、不同節日時商家的銷售策略等… 目的: 將各種不同的**演算法(策略)**封裝成類別，執行何種策略是由客戶端決定。 情境巫師們需要根據不同情況施展魔法(策略)，保護隊友使用疾疾，護法現身(Expecto Patronum)，救火用水水噴(Aquamenti)而卸除對方武器可以使用去去，武器走(Expelliarmus)。 策略模式中會規範魔法使用的規章(策略介面)，魔法的實際應用則是實體策略。使用何種魔法(策略)的依據則是巫師面對的不同景靚。 範例咒語規章(介面)與咒語(實作) 123456789101112131415161718192021222324252627282930313233343536373839/** * 咒語介面 */interface Magic { public function spell();}/** * 疾疾，護法現身 */class ExpectoPatronum implements Magic { public function spell() { return '疾疾，護法現身!'; }}/** * 水水噴 */class Aquamenti implements Magic { public function spell() { return '水水噴!'; }}/** * 去去，武器走 */class Expelliarmus implements Magic { public function spell() { return '去去，武器走!'; }} 巫師 1234567891011121314151617181920212223242526272829303132/** * 巫師 */class Wizard { /** * 使用的魔法(策略) * @var */ protected $_magic; /** * 切換魔法(策略) * @param Magic $magic */ public function choiceMagic(Magic $magic) { $this-&gt;_magic = $magic; } /** * 施咒 * @return string */ public function spell() { if ($this-&gt;_magic == null) { return '完蛋，忘記要用什麼咒語了！'; } return $this-&gt;_magic-&gt;spell(); }} 使用場景 1234567891011121314151617181920212223242526# 巫師走在路上$wizard = new Wizard();echo '巫師走在路上。';echo '&lt;/br&gt;';echo '&lt;/br&gt;';# 遇到有人被攻擊了，保護他echo '遇到路人被催狂魔攻擊！' . '&lt;/br&gt;';$wizard-&gt;choiceMagic(new ExpectoPatronum());echo '念咒: ' . $wizard-&gt;spell();echo '&lt;/br&gt;';echo '&lt;/br&gt;';# 遇到屋子燒起來了，滅火echo '遇到路邊的房子燒起來了！' . '&lt;/br&gt;';$wizard-&gt;choiceMagic(new Aquamenti());echo '念咒: ' . $wizard-&gt;spell();echo '&lt;/br&gt;';echo '&lt;/br&gt;';# 遇到別的巫師拿著魔杖指著你，搶法杖echo '遇到有人拿著法杖指著你！' . '&lt;/br&gt;';$wizard-&gt;choiceMagic(new Expelliarmus());echo '念咒: ' . $wizard-&gt;spell(); 執行結果 12345678910巫師走在路上。遇到路人被催狂魔攻擊！念咒: 疾疾，護法現身!遇到路邊的房子燒起來了！念咒: 水水噴!遇到有人拿著法杖指著你！念咒: 去去，武器走! 討論 由於介面規範的關係，各種策略間互相切換是不會出問題的，因此策略的使用上非常的靈活且易於擴充。 但若策略數量過多的話會讓維護端帶來額外的開銷。由於策略的實作是在客戶端，因此客戶端應該知道有什麼策略，並且瞭解各種策略之間的區別。 策略模式 VS 工廠模式若對工廠模式不熟悉的朋友，可到此大概了解一下。 單看類別圖或是描述及用法看起來根本一模一樣，但兩種模式各自著重的點如下： 簡單工廠模式是用來建立物件的模式，關注物件如何被產生。 策略模式是一種行為模式，關注的是行為的封裝。 簡單的來說，工廠模式著重的是產出類別(巫師)，至於類別(巫師)後續做了何種行為則跟他沒關係了。 而策略模式著重的是在策略本身，依照情況使用什麼策略，至於策略怎麼來的。就不是重點了。","link":"/2021/10/18/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"PHP上Elasticsearch應用","text":"Elasticsearch 是一個建置在 Apache Lucene 上的分散式搜尋和分析引擎。 用於日誌分析、全文搜尋、安全智慧、業務分析和營運智慧使用。 Elasticsearch 於 PHP 上應用教學。 What is Elasticsearch?Elasticsearch是一套基於Apache Lucene(TM)的開源搜尋引擎。無論在開源或專有禮遇，Lucene被認為至今最先進、性能最好、功能最齊全的搜尋引擎。 不過 Elasticsearch不僅僅是Lucene和全文搜尋，我們還能這樣去描述它： 分佈式的實時文進存儲，每個字段都被索引並可被搜尋。 分佈式的實時分析搜尋引擎。 可拓展至上百台服務器，處理ＰＢ級結構化或非結構化數據。 環境建置第一步安裝Elasticsearch環境安裝ES前請先確認JAVA環境已建置完成，可至CMD下指令 java -version。若無可至JAVA官網進行安裝及環境建置。 Elasticsearch安裝有需多不同方式(待補其他方式)。此處筆者至Elasticsearch官網直接下載最新版並解壓縮使用。 檔案包安裝好後由CMD直接進入該專案包下指令喚醒Elasticsearch bin/elasticsearch。 請注意喚醒ES不可使用root身份進行，並確認專案內部分檔案開放該身份存取(logs等…) 如何確認ES是否安裝成功？可直接使用網頁連結 http://localhost:9200/ 若出現畫面。 123456789101112131415{ &quot;name&quot; : &quot;BSQmiuK&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;d6gTLQ0-Svy1WbTWSvKmig&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;6.2.4&quot;, &quot;build_hash&quot; : &quot;ccec39f&quot;, &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.2.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot;} 代表大致上沒有問題。 如何在php上應用Elasticsearch？筆者此處使用[[https://getcomposer.org/|composer]]檔案管理套件進行ES-PHP檔案安裝。若無此套件可先進行環境建置。 PHP上使用Elasticsearch先在專案內新增composer.json檔並包含elasticsearch-php(筆者編寫時最新版本需配合php7，固取得版本5.0配合PHP 5.6)。 composer.json檔內容 12345{ &quot;require&quot;: { &quot;elasticsearch/elasticsearch&quot;: &quot;~5.0&quot; }} 完成後cmd到專案目錄下進行 composer install進行套件安裝。 於專案內新增index.php，使用自動加載並實例化客戶端。 1234require 'vendor/autoload.php';use Elasticsearch\\ClientBuilder;$client = ClientBuilder::create()-&gt;build(); 建立索引資歷。將以下code添加至index.php內12345678910$params = [ 'index' =&gt; 'my_index', 'type' =&gt; 'my_type', 'id' =&gt; 'my_id', 'body' =&gt; ['testField' =&gt; 'abc'],];$response = $client-&gt;index($params);var_dump($response); 於網頁執行應該回得到頁面訊息 12345678910111213array (size=8) '_index' =&gt; string 'my_index' (length=8) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string 'my_id' (length=5) '_version' =&gt; int 6 'result' =&gt; string 'updated' (length=7) '_shards' =&gt; array (size=3) 'total' =&gt; int 2 'successful' =&gt; int 1 'failed' =&gt; int 0 '_seq_no' =&gt; int 5 '_primary_term' =&gt; int 1 返回response為Elasticsearch創建索引返回的JSON解碼關聯表。 依條件取得索引資料12345678$params = [ 'index' =&gt; 'my_index', 'type' =&gt; 'my_type', 'id' =&gt; 'my_id',];$response = $client-&gt;get($params);var_dump($response); 我們可以依照索引設置及get取得文檔資料 123456789array (size=6) '_index' =&gt; string 'my_index' (length=8) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string 'my_id' (length=5) '_version' =&gt; int 1 'found' =&gt; boolean true '_source' =&gt; array (size=1) 'testField' =&gt; string 'abc' (length=3) 依索引刪除資料12345$deleteParams = [ 'index' =&gt; 'my_index',];$response = $client-&gt;indices()-&gt;delete($deleteParams);print_r($response); 得到確認回應 1Array ( [acknowledged] =&gt; 1 ) 關鍵字搜尋Elasticsearch可對入稿之資料內容做比對搜尋。 關鍵字若下”後山大火雞”，那”後”、”山”、”大”、”火”、”雞”、”後山”、”火雞”(請自行依此類推)皆會成為搜尋條件並找出一定比重之資料。 讓我們來看看該怎麼做。 首先幫我入稿基本資料: 12345678910111213141516171819202122232425262728$params = [ 'index' =&gt; 'my_index2', 'type' =&gt; 'my_type', 'body' =&gt; ['count' =&gt; '後山大火雞'],];$client-&gt;index($params);$params = [ 'index' =&gt; 'my_index', 'type' =&gt; 'my_type', 'body' =&gt; ['count' =&gt; '火雞'],];$client-&gt;index($params);$params = [ 'index' =&gt; 'my_index', 'type' =&gt; 'my_type', 'body' =&gt; ['count' =&gt; '後山'],];$client-&gt;index($params);$params = [ 'index' =&gt; 'my_index', 'type' =&gt; 'my_type', 'body' =&gt; ['count' =&gt; '後大'],];$client-&gt;index($params); 搜尋功能應用(其中僅入稿資料”後山” 不再搜尋關鍵字 “大火雞” 拆分比對資料內因故沒被顯示出來)。 123456789$paramsSeach['body'] = array( 'query' =&gt; array( 'match' =&gt; array( 'count' =&gt; '大火雞', ), ));$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 上述指令會取得結果 12345678910111213141516171819202122232425262728array (size=3) 0 =&gt; array (size=5) '_index' =&gt; string 'my_index' (length=8) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string 'S2fIPmMBYbAZcmkxgr3x' (length=20) '_score' =&gt; float 1.3862944 '_source' =&gt; array (size=1) 'count' =&gt; string '火雞' (length=6) 1 =&gt; array (size=5) '_index' =&gt; string 'my_index2' (length=9) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string 'SmfIPmMBYbAZcmkxgr2d' (length=20) '_score' =&gt; float 0.8630463 '_source' =&gt; array (size=1) 'count' =&gt; string '後山大火雞' (length=15) 2 =&gt; array (size=5) '_index' =&gt; string 'my_index' (length=8) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string 'TWfIPmMBYbAZcmkxg70I' (length=20) '_score' =&gt; float 0.2876821 '_source' =&gt; array (size=1) 'count' =&gt; string '後大' (length=6) 搜尋應用還可對指定索引進行搜尋，於上方資料後山大火雞可發現其陣列內index欄位與其他幾項不同。 此時只要添加索引條件: 1$paramsSeach['index'] = 'my_index'; 由於此處指定搜尋index，故會發現搜尋搜尋結果以濾掉 ['index' =&gt; 'my_index2'] 的 後山大火雞。 以上為Elasticsearch-php基本應用。其實有許多功能筆者皆未提到。例： Elasticsearch監聽程式(Elasticsearch-head)、或全域搜尋功能。還有許多分析功能。 待筆者日後對Elasticsearch掌握度更加精進後，在進行文件補充動作 以下附上DB相關進階應用: DB與ES數據庫連結(conn.php) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phprequire_once 'vendor/autoload.php';//連結MySql資料庫function get_conn(){ @$conn = mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;) or die(&quot;error connecting&quot;); mysql_select_db(&quot;DBName&quot;, $conn); # *DB請自行填入 mysql_query(&quot;SET NAMES 'UTF8'&quot;); return $conn;}//由DB取得資料並回存ES中function create_index($maxId, $client){ //取捯DB資料 $sql = &quot;SELECT * FROM tableName where id &gt; $maxId limit 0,300&quot;; # *資料表名稱請自行填入 get_conn(); @$result_bugs = mysql_query($sql); while (@$row = mysql_fetch_assoc(@$result_bugs)) { $rtn[] = $row; } foreach ($rtn as $val) { $params = array(); $params['body'] = array( 'id' =&gt; $val['id'], 'count' =&gt; $val['count'], # *請自行修改比對欄位及名稱 ); $params['index'] = 'index'; $params['type'] = 'title'; $client-&gt;index($params); } return (count($rtn) == 300) ? $val['id'] : false;}// set_time_limit(0);$client = Elasticsearch\\ClientBuilder::create()-&gt;setHosts(['localhost'])-&gt;build();//刪除所有數據// $client-&gt;indices()-&gt;delete(['index' =&gt; 'index']);$a = true;$maxId = 0;while ($a) { $maxId = create_index($maxId, $client); if (empty($maxId)) { $a = false; }} 執行php(testConn.php) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php//引入DB連結require 'conn.php';require_once 'vendor/autoload.php';function search($keyword, $page = 0, $size = 20){ //實體化對象 $client = Elasticsearch\\ClientBuilder::create()-&gt;setHosts(['localhost'])-&gt;build(); //查詢數據庫拼裝 $params = array(); $params['index'] = 'index'; $params['type'] = 'title'; $params['body']['query']['match']['count'] = $keyword; $params['from'] = $page; $params['size'] = $size; //查詢 $rtn = $client-&gt;search($params)['hits']; //結果組裝 $data['total'] = $rtn['total']; $data['lists'] = array_column($rtn['hits'], '_source'); $data['lists'] = formartData(array_column($data['lists'], 'id')); return $data;}function formartData($ids){ $ids = implode($ids, ','); $sql = &quot;select * from articles where id in($ids)&quot;; $data = mysql_query($sql); $rtn = []; while (@$row = mysql_fetch_assoc(@$data)) { $rtn[] = $row; } return $rtn;}$q0 = isset($_GET['q']) ? $_GET['q'] : 'SQL注入';$num = &quot;15&quot;; //每頁顯示比數$page = isset($_GET['page']) ? intval($_GET['page']) : 1;$offset = ($page - 1) * $num;$esData = search($q0, $offset, $num);var_dump($esData); 使用方式：呼叫程式並賦予搜尋值。 12http://localhost/testConn.php?q= 注意1:索引(index) 與 型態(type) 設定時必須小寫。 聲明:此篇教學僅提供學習與交流使用，請勿用於商業用途。 參考資料 elasticsearch PHP使用elasticsearch搜索安装及分词方法 Elasticsearch的功能、使用场景以及特点","link":"/2021/11/30/PHP%E4%B8%8AElasticsearch%E6%87%89%E7%94%A8/"},{"title":"設計模式 - 職責鏈模式","text":"各司其職的物件串成一鏈，依照此鏈傳遞並處理請求。 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹 職責鏈屬於行為型模式，在這種模式中，通常每個接收者都包含對另一個接收者的引用。如果一個對象不能處理該請求，那麼它會把相同的請求傳給下一個接收者，依此類推。 組成 Handler: 定義一個處理請求的接口，包含抽象處理方法及後續方法。 ConcreteHandler: 實作Handler的處理方法，判斷是否可以處理這次的請求，可以則處理，不行則往後傳。 情境一般來說，一間公司核准請假天數的權限會因為職階而有所差異。像是主管的上限是七天，經理是十五天。超過十五天則需要老闆批准。 當有員工要請十天假，組長無法核准這個假別，就會再往下一層提交。這就是責任鏈模式。 範例抽象處理層 1234567891011121314151617181920212223242526272829# 抽象處理者abstract class Leader{ protected $next; protected String $name; public function setNext(Leader $next) { $this-&gt;next = $next; } public function getLeader(): Leader { return $this-&gt;next; } public function leaveSuccessed(int $days) { echo $this-&gt;name . '已批准你申請 ' . $days . ' 天假期！'; } public function leaveFailed() { echo '請假天數太高，無可核准權限主管！'; } abstract public function handleRequest(int $days);} 各職階長官 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 組長(7天)class Director extends Leader{ protected String $name = '主管'; public function handleRequest(int $days) { if ($days &lt;= 7) { $this-&gt;leaveSuccessed($days); } else { if ($this-&gt;next) { $this-&gt;next-&gt;handleRequest($days); } else { $this-&gt;leaveFailed(); } } }}# 經理(15天)class Manager extends Leader{ protected String $name = '經理'; public function handleRequest(int $days) { if ($days &lt;= 15) { $this-&gt;leaveSuccessed($days); } else { if ($this-&gt;next) { $this-&gt;next-&gt;handleRequest($days); } else { $this-&gt;leaveFailed(); } } }}# 老闆class Boss extends Leader{ protected String $name = '老闆'; public function handleRequest(int $days) { $this-&gt;leaveSuccessed($days); }} 組裝鏈 12345678910111213141516171819class LeaveApproval{ public function main(int $days) { # 組長 $director = new Director(); # 經理 $manager = new Manager(); # 老闆 $boss = new Boss(); $director-&gt;setNext($manager); $manager-&gt;setNext($boss); $director-&gt;handleRequest($days); }} 員工請假 123$leaveApproval = new LeaveApproval();$leaveApproval-&gt;main(30);exit; 結果 1老闆已批准你申請 30 天假期！ 也可以將鍊理到老闆移掉(老闆不在家)，會得到結果 1請假天數太高，無可核准權限主管！ 討論責任鏈模式中有兩個行為，一個是承擔責任，另一個則是把責任往下推。承擔責任又可分為全責承擔與部分承擔，部分承擔允許只承擔部分責任，將其餘的責任往下推的情況，而且一個請求可以最終不被任何接收端對象所接收。 職責鏈模式的定義讓多個物件都有機會處理請求，從而避免請求的發送者和接收者之間的耦合關係。","link":"/2021/12/11/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E8%81%B7%E8%B2%AC%E9%8F%88%E6%A8%A1%E5%BC%8F/"},{"title":"設計模式 - 觀察者模式","text":"想要我的財寶嗎？想要的話可以全部給你，自己去找吧！我把所有財寶都放在那裡。 不用這麼麻煩！訂閱我，最新的財寶資訊將會主動送到您手上！ 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹觀察者屬於行為模式，定義物件間的一對多的依賴關系，當一個被依賴物件的狀態發生改變時，所有依賴於它的物件都被自動更新。 以 Youtuber 來說，他們會邀請觀看者訂閱小鈴鐺，這個訂閱功能就像「主題」與「觀察者」之間的關係，只要你開啟訂閱，在新影片發布時，系統會自動通知你。當然「觀察者」也可以隨時退訂。 組成 被觀察者(Observable)： 定義了訂閱、取消訂閱、更新通知。 觀察者(Observer)： 定義更新狀態方法，供被通知者進行通知行為。 情境哥爾羅傑和白鬍子為了提高自己的知名度，會不定時放送自己的財寶資訊。讓各位海賊們觀看。 部分鐵粉海賊會進行訂閱自己的支持者以免錯過訊息。其中不乏兩位都訂閱的海賊。 範例定義介面 1234567891011# 觀察者interface IObserver { public function update();}# 抽象被觀察者interface IObservable { public function add(IObserver $observer); public function remove(IObserver $observer); public function notify();} 角色實作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 大海賊(被觀察者)class BigPirate implements IObservable { protected string $name; protected array $observerAry=[]; public function __construct(string $name) { $this-&gt;name = $name; } /** * 訂閱 * @param IObserver $observer */ public function add(IObserver $observer) { if (!in_array($observer, $this-&gt;observerAry)) { $this-&gt;observerAry[] = $observer; echo '已訂閱' . $this-&gt;name . '&lt;br/&gt;'; } } /** * 取消訂閱 * @param IObserver $observer */ public function remove(IObserver $observer) { if (in_array($observer, $this-&gt;observerAry)) { $key = array_search($observer, $this-&gt;observerAry); unset($this-&gt;observerAry[$key]); echo '已取消訂閱' . $this-&gt;name . '&lt;br/&gt;'; } } /** * 通知更新 */ public function notify() { foreach ($this-&gt;observerAry as $observer) { $observer-&gt;update($this-&gt;name . '已發布最新寶藏資訊'); } }}# 海賊(觀察者)class Pirate implements IObserver { protected string $name; public function __construct(string $name) { $this-&gt;name = $name; } public function update(string $notice) { echo '給' . $this-&gt;name . '，' . $notice . '&lt;br/&gt;'; }} 來看看魯來訂閱兩位大海賊，又取消訂閱白鬍子後。大海賊發新片的狀況吧。 12345678910111213141516171819# 大海賊們$roger = new BigPirate('哥爾羅傑');$edward = new BigPirate('白鬍子');# 海賊$luffy = new Pirate('魯夫');# 訂閱$roger-&gt;add($luffy);$edward-&gt;add($luffy);# 取消訂閱$edward-&gt;remove($luffy);# 哥爾羅傑發新片$roger-&gt;notify();# 白鬍子發新片$edward-&gt;notify(); 結果 1234已訂閱哥爾羅傑已訂閱白鬍子已取消訂閱白鬍子給魯夫，哥爾羅傑已發布最新寶藏資訊 討論觀察者模式可有效解除關聯物件間的高耦合問題，只要正確實作 IObserver (觀察者) 介面就可以對有興趣的主題進行訂閱行為。而透過介面的規範可以確保實作出來的觀察者具備必要的方法函示。 觀察者模式下觀察者可透過訂閱避免頻繁向被觀察者查詢是否有新作品的問題。","link":"/2022/01/12/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"設計模式 - 單例模式","text":"我就是我，獨一無二的我。 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹 單例模式屬於創建型模式，目的是保證一個類別只會產生一個物件，而且要提供存取該物件的統一方法。 情境哈利與鄧不利多分別攻擊伏地魔，而伏地魔應該要因為攻擊而被層層削弱。 錯誤範例哈利、鄧不利多和伏地魔的物件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 伏地魔class Voldemort { private $blood = 7; /** * 扣除血量 * @param int $del */ public function deduct(int $del) { $this-&gt;blood = $this-&gt;blood - $del; } /** * 顯示血量 * @return int */ public function show() { return $this-&gt;blood; }}# 鄧不利多class Dumbledore { public function attack() { $voldemort = new Voldemort(); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; echo '鄧不利多攻擊 ' . '&lt;br /&gt;'; $voldemort-&gt;deduct(3); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; }}# 哈利class Harry { public function attack() { $voldemort = new Voldemort(); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; echo '哈利波特攻擊 ' . '&lt;br /&gt;'; $voldemort-&gt;deduct(1); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; }} 揍他 123456789$Dumbledore = new Dumbledore();$Harry = new Harry();echo '鄧不利多攻擊 &lt;br /&gt;';$Dumbledore-&gt;attack();echo '&lt;br /&gt;';echo '哈利波特攻擊 &lt;br /&gt;';$Harry-&gt;attack(); 結果 123456789鄧不利多攻擊伏地魔剩餘分靈體數量: 7鄧不利多攻擊伏地魔剩餘分靈體數量: 4哈利波特攻擊伏地魔剩餘分靈體數量: 7哈利波特攻擊伏地魔剩餘分靈體數量: 6 咦！！！為什麼大魔王打不死！？ 那是因為哈利跟老鄧分別實例化了自己的佛地魔。攻擊當然沒有串連起來囉。 正確範例讓我們套用單例調整佛地魔的實例化方式。 哈利、鄧不利多和伏地魔的物件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 伏地魔class Voldemort { private static $instance; private $blood = 7; private function __construct() { # 建構方式虛擬化，確保無法從外部實例物件 } /** * 取得伏地魔物件 * @return Voldemort */ public static function getInstance() { if (!self::$instance) { self::$instance = new self(); } return self::$instance; } /** * 扣除血量 * @param int $del */ public function deduct(int $del) { $this-&gt;blood = $this-&gt;blood - $del; } /** * 顯示血量 * @return int */ public function show() { return $this-&gt;blood; }}# 鄧不利多class Dumbledore { public function attack() { $voldemort = Voldemort::getInstance(); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; echo '鄧不利多攻擊 ' . '&lt;br /&gt;'; $voldemort-&gt;deduct(3); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; }}# 哈利class Harry { public function attack() { $voldemort = Voldemort::getInstance(); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; echo '哈利波特攻擊 ' . '&lt;br /&gt;'; $voldemort-&gt;deduct(1); echo '伏地魔剩餘分靈體數量: ' . $voldemort-&gt;show() . '&lt;br /&gt;'; }} 將伏地魔建構元私有化，確保其他人無法從外部實例化。 建立 instance 實例機制，讓物件永遠保持單一。 再來，揍他 123456789$Dumbledore = new Dumbledore();$Harry = new Harry();echo '鄧不利多攻擊 &lt;br /&gt;';$Dumbledore-&gt;attack();echo '&lt;br /&gt;';echo '哈利波特攻擊 &lt;br /&gt;';$Harry-&gt;attack(); 結果 鄧不利多攻擊 伏地魔剩餘分靈體數量: 7 鄧不利多攻擊 伏地魔剩餘分靈體數量: 4 哈利波特攻擊 伏地魔剩餘分靈體數量: 4 哈利波特攻擊 伏地魔剩餘分靈體數量: 3 討論此處筆者僅將佛地魔物件當成單例範例，其他範例可以想像倉庫與送貨員，班導師與學生之間的關係。 單例模式能確保共同物件的單一使用及系統效能的優化。算是簡單好用的設計模式。 許多知名的 Framework 底層也有實作此模式，有興趣的可以多加參考。","link":"/2022/01/21/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"PHP上Elasticsearch應用-搜尋篇","text":"對 Elasticsearch 還不熟悉？ 請參考 Elasticsearch-PHP|PHP上Elasticsearch應用。 Elasticsearch 文章簡寫 ES。 懶人包比對方式： TERM ： 完全符合。 MATCH ： 拆字，模糊搜尋。 MATCH_PHRASE ： 不拆字，模糊搜尋。 MATCH_PHRASE_PREFIX ： 不拆字，精準，模糊搜尋。 搜尋條件： must : 多項查詢條件完全匹配,相當於 AND。 must_not : 多個查詢條件相反匹配，相當於 NOT。 should : 至少有一個條件匹配,相當於 OR。 因為筆者比較喜歡看到東西能動，再去了解他為什麼可以動。 所以此處我們先做一個小範例(此處不在教學環境建置及套件載入，各位讀者請自行各顯神通讓程式碼能動)。 搜尋精準度讓我們先放置資料進 ES 中。 123456789101112131415161718192021222324&lt;?phprequire 'vendor/autoload.php';use Elasticsearch\\ClientBuilder;$client = ClientBuilder::create()-&gt;build(); $params = [ 'index' =&gt; 'my_index2', 'type' =&gt; 'my_type', 'id' =&gt; 1, 'body' =&gt; ['count' =&gt; '後山大火雞'], ]; $client-&gt;index($params); $params = [ 'index' =&gt; 'my_index2', 'type' =&gt; 'my_type', 'id' =&gt; 2, 'body' =&gt; ['count' =&gt; '後山大火災'], ]; $client-&gt;index($params); 在下搜尋指令 12345678910$paramsSeach['index'] = 'my_index2';$paramsSeach['body'] = array( 'query' =&gt; array( 'match' =&gt; array( 'count' =&gt; '火雞', ), ));$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 畫面就會出現資料 1234567891011121314151617181920/Applications/MAMP/htdocs/jesda/es/index.php:97:array (size=2) 0 =&gt; array (size=5) '_index' =&gt; string 'my_index2' (length=9) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string '1' (length=1) '_score' =&gt; float 0.5753642 '_source' =&gt; array (size=1) 'count' =&gt; string '後山大火雞' (length=15) 1 =&gt; array (size=5) '_index' =&gt; string 'my_index2' (length=9) '_type' =&gt; string 'my_type' (length=7) '_id' =&gt; string '2' (length=1) '_score' =&gt; float 0.2876821 '_source' =&gt; array (size=1) 'count' =&gt; string '後山大火災' (length=15) 怪了？我搜尋火雞關你後山大火災屁事。 對於 ES 有基本程度了解都知道，因為 ES 進行了字詞切割並比對搜尋。 那如果我們就是想要搜尋火雞就好，那怎麼辦呢？ 讓我們將指令內 match 替換成 match_phrase 試試看。 代碼如下: 12345678910$paramsSeach['index'] = 'my_index2';$paramsSeach['body'] = array( 'query' =&gt; array( 'match_phrase' =&gt; array( 'count' =&gt; '火雞', ), ));$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 你將會看到，結果只剩下後山大火雞，而火災呢？ 天要下雨娘要嫁人，隨它去吧～ 對此搜尋關鍵字筆者有找到幾個比較常用的可以做一下介紹。 TERM ： 完全符合。 MATCH ： 拆字，模糊搜尋。 MATCH_PHRASE ： 不拆字，模糊搜尋。 MATCH_PHRASE_PREFIX ： 不拆字，精準，模糊搜尋。 在此特別提一下 MATCH_PHRASE 與 MATCH_PHRASE_PREFIX 。 兩者差別在於，MATCH_PHRASE 在文章內搜尋關鍵字比重過低情況下該文檔會被忽略。而 MATCH_PHRASE_PREFIX 可解決這個問題。 當然還有調整搜尋的精準度可以進行調整，但此時筆者功力太淺。先以此解法解決部分文檔因為搜尋比重太低而被忽略問題了。 看到這裡可能會有人覺得，那我可不可以對文檔內資料做複合式搜尋。 猶如 SQL 指令 AND、OR、NOT IN 等等，要 A 要 B 不要 C。 有！都有！ 讓我們繼續往下走。 複合式搜尋在此我們先將資料洗一下。 讓我們來見識 NBA 大名鼎鼎的四位球員(文章主軸不是探討 NBA 球員，故只取球員部分生涯數據 )。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 $params = [ 'index' =&gt; 'nba', 'type' =&gt; 'nba', 'id' =&gt; 1, 'body' =&gt; [ 'name' =&gt; 'Kobe Bryant', 'position' =&gt; '後衛', 'glory' =&gt; '總冠軍 最有價值球員 得分王 全明星賽 神' ], ]; $client-&gt;index($params); $params = [ 'index' =&gt; 'nba', 'type' =&gt; 'nba', 'id' =&gt; 2, 'body' =&gt; [ 'name' =&gt; 'Steve Nash', 'position' =&gt; '後衛', 'glory' =&gt; '最有價值球員 助攻王 全明星賽' ], ]; $client-&gt;index($params);$params = [ 'index' =&gt; 'nba', 'type' =&gt; 'nba', 'id' =&gt; 3, 'body' =&gt; [ 'name' =&gt; 'LeBron James', 'position' =&gt; '前鋒', 'glory' =&gt; '總冠軍 最有價值球員 得分王 全明星賽' ],];$client-&gt;index($params);$params = [ 'index' =&gt; 'nba', 'type' =&gt; 'nba', 'id' =&gt; 4, 'body' =&gt; [ 'name' =&gt; 'Shaquille O\\'Neal', 'position' =&gt; '中鋒', 'glory' =&gt; '總冠軍 最有價值球員 得分王 全明星賽' ],];$client-&gt;index($params); 讓我們看一下，ES 提供的搜尋條件有哪些： must : 多項查詢條件完全匹配,相當於 AND。 must_not : 多個查詢條件相反匹配，相當於 NOT。 should : 至少有一個條件匹配,相當於 OR。 讓我們來看看如何使用。先來最簡單的，找出得過 最有價值球員 榮耀的。 12345678910$paramsSeach['index'] = 'nba';$paramsSeach['body'] = array( 'query' =&gt; array( 'match_phrase' =&gt; array( 'glory' =&gt; '最有價值球員', ), ));$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 結果輸出是四位球員，那如果要同時擁有 最有價值球員 與 得分王呢？ 12345678910111213$paramsSeach['index'] = 'nba';$paramsSeach['body'] = array( 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '最有價值球員'], 'match_phrase' =&gt; ['glory' =&gt; '得分王'], ], ], ],);$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 這邊直接將搜尋條件 query 內應用換掉，讓他可以達成 最有價值球員 AND 得分王 的搜尋條件。可以看到 Steve Nash 被篩選掉了。 小叮嚀：若是搜尋類型使用 match 因為會幫你拆字搜尋，所以 得分王/助攻王 都會被條件找出來。導致沒有達到此處想要的效果。 這邊想要或是 只要得過 助攻王 的就被顯示出來。 等同搜尋條件上的 OR。 123456789101112131415161718192021222324252627$paramsSeach['index'] = 'nba';$paramsSeach['body'] = array( 'query' =&gt; [ 'bool' =&gt; [ 'should' =&gt; [ [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '最有價值球員'], 'match_phrase' =&gt; ['glory' =&gt; '得分王'], ], ], ], [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '助攻王'], ], ], ] ] ], ],);$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 這邊組成比較複雜一些，我們可以將搜尋條件看成： 123$bool['bool']['msut'] =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '最有價值球員'],]; 在一個一個放入 should 的陣列中，就能在裡面形成 OR 的條件效果。 仔細想想，把 神 放入凡人中是不是太不公平了些，我們這邊就將 神 排除掉(添加條件 must_not)。 123456789101112131415161718192021222324252627282930$paramsSeach['index'] = 'nba';$paramsSeach['body'] = array( 'query' =&gt; [ 'bool' =&gt; [ 'should' =&gt; [ [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '最有價值球員'], 'match_phrase' =&gt; ['glory' =&gt; '得分王'], ], ], ], [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '助攻王'], ], ], ] ], 'must_not' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '神'], ], ], ],);$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 以上就是搜尋的簡單應用，其實還有一個搜尋的使用訪法。只是筆者還未能掌握，在此順便提供。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748\b# 加了這段[ 'match' =&gt; [ 'position' =&gt; [ 'query' =&gt; '前鋒 後衛', 'operator' =&gt; 'or', ], ],],$paramsSeach['index'] = 'nba';$paramsSeach['body'] = array( 'query' =&gt; [ 'bool' =&gt; [ 'should' =&gt; [ [ 'bool' =&gt; [ 'must' =&gt; [ ['match_phrase' =&gt; ['glory' =&gt; '最有價值球員']], ['match_phrase' =&gt; ['glory' =&gt; '得分王']], [ 'match' =&gt; [ 'position' =&gt; [ 'query' =&gt; '前鋒 後衛', 'operator' =&gt; 'or', ], ], ], ], ], ], [ 'bool' =&gt; [ 'must' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '助攻王'], ], ], ] ], 'must_not' =&gt; [ 'match_phrase' =&gt; ['glory' =&gt; '神'], ], ], ],);$results = $client-&gt;search($paramsSeach);var_dump($results['hits']['hits']); 本來預想篩選出 position 是 前鋒 或 後衛 的資料。但因 match 關係 前鋒會被進行拆字搜尋。待筆者日後 ES 精進了再來進行編寫。 聲明:此篇教學僅提供學習與交流使用，請勿用於商業用途。 參考資料Elasticsearch 学习笔记(一) 初窥 Elasticsearch-PHP [1.0]","link":"/2022/02/22/PHP%E4%B8%8AElasticsearch%E6%87%89%E7%94%A8-%E6%90%9C%E5%B0%8B%E7%AF%87/"},{"title":"設計模式 - 享元模式","text":"享元模式，亦稱：緩存、Cache、Flyweight。 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹享元模式是一種結構型設計模式，透過減少創建物件內的重複數據，來減少內存佔用和提高性能。讓你能在有限的內存容量中載入更多物件。 情境玩過戰略型遊戲(如: 世紀帝國)的人都知道，遊戲內是可以大量生產各種士兵的。相同種類的士兵外型、能力、行為都是相同的，但會有各自的位置及血量。 若是系統將大量士兵物件各自實例化，那可能導致佔用過多系統資源，導致遊玩順暢度不盡理想。 讓我們來看看如何利用享元來解決此問題。 範例士兵類型(定義了士兵種類的名稱、能力、行為) 1234567891011121314151617181920212223242526# 士兵抽象類別abstract class ASoldier { # 出生 public function initXY(int $key, int $x, int $y) { echo $this-&gt;name . ' ' . $key . ' 出生，初始位置 X: ' . $x . ' Y: ' . $y . '&lt;br/&gt;&lt;br/&gt;'; } # 移動 public function move(int $key, int $x, int $y) { echo $this-&gt;name . ' ' . $key . ' 移動至 X: ' . $x . ' Y: ' . $y . '&lt;br/&gt;&lt;br/&gt;'; }}# 步兵class Infantry extends ASoldier { protected $name = '步兵'; protected $power = 10;}# 弓箭手class Archer extends ASoldier { protected $name = '弓箭手'; protected $power = 20;} 士兵產生工廠(用於進行士兵類型取得) 123456789101112131415161718192021# 士兵工廠class SoldierFactory { protected $soldier = []; # 取得對應士兵實作 public function getSoldierType($key) { if (!isset($this-&gt;soldier[$key])) { $this-&gt;soldier[$key] = new $key(); } return $this-&gt;soldier[$key]; } # 計算物件數量 public function countObj() { echo '士兵類型數量: ' . count($this-&gt;soldier); }} 產生各種種類的士兵並讓他們亂動吧！ 123456789101112131415161718192021# 士兵生產工廠$soldierFactory = new SoldierFactory();# 生產步兵 1 號$Infantry1 = $soldierFactory-&gt;getSoldierType('Infantry');$Infantry1-&gt;initXY(1, 100, 200);# 生產步兵 2 號$Infantry2 = $soldierFactory-&gt;getSoldierType('Infantry');$Infantry2-&gt;initXY(2, 100, 200);# 生產弓兵 1 號$Archer1 = $soldierFactory-&gt;getSoldierType('Archer');$Archer1-&gt;initXY(1, 100, 200);# 開始亂跑$Infantry1-&gt;move(1, 400, 100);$Infantry2-&gt;move(2, 300, 200);$Archer1-&gt;move(1, 500, 700);$soldierFactory-&gt;countObj(); 可獲得結果 12345678910111213步兵 1 出生，初始位置 X: 100 Y: 200步兵 2 出生，初始位置 X: 100 Y: 200弓箭手 1 出生，初始位置 X: 100 Y: 200步兵 1 移動至 X: 400 Y: 100步兵 2 移動至 X: 300 Y: 200弓箭手 1 移動至 X: 500 Y: 700士兵類型數量: 2 結論 我們可以看到，就算我們產生了 3 隻士兵(不同種類)，但士兵類型的物件卻只實作了 2 個。 因為我們將士兵拆成了內在狀態(屬性)與外在狀態(編號、座標)。進而透過共享內在狀態(屬性)去節省系統效能的使用。 討論若物件中有很多相似屬性， 那麼享元將可以節省大量內存。但由於物件屬性的拆分，程式碼將會會變得更加復雜。 效能提升的代價就是維護的效率。 享元 VS 單例享元模式與單例模式結構上非常相似，都是透過重複使用實例化物件來節省系統效能。差別在於，單例模式只會有一個實體， 而享元可以有多個實體， 各實體的內在狀態也可以不同。","link":"/2022/03/20/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"PHP OO 基礎教學","text":"此篇教學只是物件導向的基礎與實作，內容只包含類別與物件的操作，讓不熟悉類別的人可以初識物件導向的好處，並且了解物件與類別的特性與關係。 認識物件導向 Object Oriented:物件導向是一種寫程式的方式，他傾向讓開發者將類似或有關聯性的工作或屬性組織到類別(class)裡面。進而讓程式遵循 不重複原則 don’t repeat yourself (DRY) ，且更容易維護。 “Object-oriented programming is a style of coding that allows developers to group similar tasks into classes.” 一、 認識物件(Object)與類別(Class) - Understanding Objects and Classes首先，先來了解物件(Object)與類別(Class)的功能及用途。 類別(Class)，可以比喻為一棟建築的設計藍圖，清楚的定義了建築的結構及形狀。 物件(Object)，可以比喻為一棟真的房子，物件是類別的實例化。 而資料(Data就是房子所需要的材料(如 鋼筋、電線、混泥土)若沒有依照**設計藍圖(類別Class)**來組裝，那材料就僅僅是一堆材料。 但當材料(資料Data)依照設計藍圖(類別Class)來實作後，那這些材料(資料Data)就會變成一個有組織且有用的房子(物件Object) 類別定義了結構以及行為，並且用這些東西打造物件。當多個物件都是由同一個類別產生出來時，每個物件都是一個獨立的個體，且不相依賴的。 二、建立類別 Class建立類別的語法很簡單，使用class來定義一個類別，然後在類別名稱後面再加上大括號{} 123456&lt;?phpclass MyClass{ // 類別的屬性與方法要在大括號裡面宣告。 // Class properties and methods go here} 建立類別後，可以使用 new 關鍵字來實例化類別，並存到一個變數上。 1$obj = new MyClass(); 使用 var_dump 來查看物件內容。 1var_dump($obj); 現在，建立一個 test.php 來測試看看吧。 12345678class MyClass{ // 類別的屬性與方法要在大括號裡面宣告。 // Class properties and methods go here}$obj = new MyClass();var_dump($obj); 贏該會輸出類似畫面(輸出畫面會因環境不同而有些許差別): 1object(MyClass)[1] 這就是一個最簡單的物件形式。你已經完成第一個物件導向程式了。 三、定義類別(Class)的屬性(Properties) - Defining Class Properties使用屬性(Properties)又稱類別的變數(Variable)，用來將資料(Data)存入類別中。存取用法就跟普通變數一樣，除非這些變數被物件給綁定了，被綁定的變數只能由物件本身存取。 替 MyClass 添加一個屬性(Properties): 12345678&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;;}$obj = new MyClass();var_dump($obj); 指定要讀取的物件以及屬性，並將它顯示在瀏覽器上： 1echo $obj-&gt;prop1; 因為類別可以被實例化為很多個物件。故若無明確指定被實例化的物件，會導致程式碼無法判斷應該讀取哪個物件。 箭頭 -&gt; 在 PHP 的物件中用來調用物件內的屬性（Property）及方法（Methods）。 現在，修改 test.php 來取得物件（Property）內的屬性（Methods）。 12345678&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;;}$obj = new MyClass();echo $obj-&gt;prop1; 重新整理一下你的瀏覽器，得到以下結果： 1I'm a class property! 四、定義類別(Class)的方法(Methods) Defining Class Methods方法（Methods）是類別裡面的函式（Functions），物件可以藉由執行這些方法來更動每個物件的行為或狀態。讓我們建立方法來設置/取得屬性 $prop1 的值: 123456789101112131415161718&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}$obj = new MyClass();echo $obj-&gt;prop1; 小筆記 物件導向允許物件透過 $this 關鍵字來參考自己。物件使用 $this 就如同使用物件名稱來指定物件，如： myClass-&gt;prop1 要調用這些含有 $this 的方法之前，記得要先實例物件。讀取 MyClass 類別的屬性，更改屬性的值。最後再把屬性輸出到瀏覽器上： 12345678910111213141516171819202122&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}$obj = new MyClass();echo $obj-&gt;getProperty(); // Get the property value$obj-&gt;setProperty(&quot;I'm a new property value!&quot;); // Set a new oneecho $obj-&gt;getProperty(); // Read it out again to show the change 重新整理你的瀏覽器，得到以下結果： 12I'm a class property!I'm a new property value! 當同一個類別被實例化越多次的時候，OOP 的力量也會隨著變得更強大。The power of OOP becomes apparent when using multiple instances of the same class. 讓我們來實例化多個類別: 12345678910111213141516171819202122232425262728293031&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}// Create two objects$obj = new MyClass;$obj2 = new MyClass;// Get the value of $prop1 from both objectsecho 'obj1: ' . $obj-&gt;getProperty();echo 'obj2: ' . $obj2-&gt;getProperty();// Set new values for both objects$obj-&gt;setProperty(&quot;I'm a new property value!&quot;);$obj2-&gt;setProperty(&quot;I belong to the second instance!&quot;);// Output both objects $prop1 valueecho 'obj1: ' . $obj-&gt;getProperty();echo 'obj2: ' . $obj2-&gt;getProperty(); 重新整理你的瀏覽器，得到以下結果： 1234obj1: I'm a class property!obj2: I'm a class property!obj1: I'm a new property value!obj2: I belong to the second instance! 物件導向將物件視為獨立個體，就如同 150 間房子都是獨立的一樣。這個特性讓原本要寫 150 次重複的程式碼可以應用類別多個物件再設置各自的內部材料(Data)。達到**程式碼不重複原則 ”Don’t Repeat yourself”(DRY)**。 封裝 Encapsulation封裝是以資料為核心，將相關的資料放在一起，把會用到這些資料的方法也放進來。為了和非OO的領域做區隔，OO做了名詞上的改變如：將函式（Function）改為 方法（Method）、將呼叫 （Call）改為調用（Invoke）。一般會以類別來封裝有相關的行為與資料。 對事物的封裝是指，將事物進行抽象後，提供抽象概念的實現的具體方法。 五、魔術函數 Magic Methods in OOPPHP 提供了幾個魔術函數讓操作物件(object)變得更簡單，這些魔術函數會在物件發生特定行為時被呼叫。這讓開發者更容易達成某些有用的任務。 更多魔術函數可以看: PHP 官方網站的魔術函數文件 使用 Constructor當一個物件被建立時，它經常需要做一些初始化。PHP 提供了一個 __construct() 的魔術函數，當一個物件被建立的時候會被呼叫。 讓我們增加一個 __construct() 到 MyClass，讓 MyClass被實例化的時候，丟出一段訊息： 123456789101112131415161718192021222324252627282930&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}// Create a objects$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho 'End of file.&lt;br /&gt;'; 小筆記 __CLASS__ 叫做魔術常數 magic constant.會回傳被呼叫的類別的名稱。 更多魔術常數可以看: PHP 官方網站的魔術常數文件 重新整理你的瀏覽器，得到以下結果： 123The class &quot;MyClass&quot; was initiated!I'm a class property!End of file. 使用 Destructors在物件被摧毀的時候呼叫 __destruct() 魔術函數，這對於清除一個物件來說很有用(例如：關閉資料庫連線等…） 增加一個 __destruct() 到 MyClass，讓 MyClass被摧毀的時候，丟出一段訊息： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}// Create a objects$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho 'End of file.&lt;br /&gt;'; 重整頁面，得到訊息: 1234The class &quot;MyClass&quot; was initiated!I'm a class property!End of file.The class &quot;MyClass&quot; was destroyed. 小筆記 當一個物件使用完畢時，PHP 會自動釋放其記憶體。“When the end of a file is reached, PHP automatically releases all resources.” 為了更明確的觸發 __destruct() 魔術函數，可以透過 unset() 方法來摧毀物件： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}// Create a objects$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Destroy the objectunset($obj);// Output a message at the end of the fileecho 'End of file.&lt;br /&gt;'; 重新整理頁面後會顯示以下結果： 1234The class &quot;MyClass&quot; was initiated!I'm a class property!The class &quot;MyClass&quot; was destroyed.End of file. __toString 將物件轉換為字串PHP 提供 __toString() 魔術函數來避免程式試圖將 MyClass 當作字串輸出到瀏覽器上。(被當作字串處理時觸發) 如果把物件當作字串處理的話，在 PHP 中會出現無法轉換型態的錯誤： 12345// Create a new object$obj = new MyClass;// Output the object as a stringecho $obj; 結果如下： 12The class &quot;MyClass&quot; was initiated!Catchable fatal error: Object of class MyClass could not be converted to string in /Applications/MAMP/htdocs/CYOProject/ooptest/test.php on line 40 為了避免發生轉換型態的錯誤，加入一個 __toString() 函數來做轉換處理： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}// Create a objects$obj = new MyClass;// Output the object as a stringecho $obj;// Destroy the objectunset($obj);// Output a message at the end of the fileecho 'End of file.&lt;br /&gt;'; 在這個情況下，嘗試將物件轉換成字串的時候，會觸發 __toString 函數，再由 __toString 函數呼叫 getProperty() 方法。重新整理瀏覽器來查看最新的結果： 1234The class &quot;MyClass&quot; was initiated!Using the toString method: I'm a class property!The class &quot;MyClass&quot; was destroyed.End of file. 除了本章節提到的 __construct、__destruct、__toString 三個魔術函數以外，還有更多魔數函數可以在 PHP 手冊 中可以學習唷！ 六、類別繼承 Class Inheritance使用 extend 關鍵字可以讓類別繼承其他類別的方法(methods)和屬性(property)。範例：建立一個新的類別並且繼承(extends) MyClass 類別，新的類別可以使用 MyClass 原有的方法(methods)和屬性(property)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; }}// Create a objects$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty(); 網頁重新整理後，可以看見以下結果： 1234The class &quot;MyClass&quot; was initiated!From a new method in MyOtherClass.I'm a class property!The class &quot;MyClass&quot; was destroyed. 覆寫(Override) 繼承的方法和屬性你可以在新類別裡面重新定義來更改繼承的屬性和方法的行為： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; }}// Create a objects$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty(); 輸出結果應為複寫後的輸出文字: 1234A new constructor in MyOtherClass.From a new method in MyOtherClass.I'm a class property!The class &quot;MyClass&quot; was destroyed. 保留父類別的方法 —-範圍解析運算子(scope resolution operator)通常父類別同名方法的程式碼內容很多，不可能就幾行，如果我們想保留原有的功能，另外再擴展出一點點的功能，但是又不想把原有的程式碼再重寫一次，這樣就可以使用範圍解析運算子::來呼叫父類別中被原定義的方法。 於 __construct 內使用範圍解析運算子(scope resolution operator) :: 來調用父類別原定義的函數： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } public function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; }}// Create a objects$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty(); 輸出結果可見，雖然在 MyOtherClass 建構元(__construct)中同時調用了父類別所定義的方法: 12345The class &quot;MyClass&quot; was initiated!A new constructor in MyOtherClass.From a new method in MyOtherClass.I'm a class property!The class &quot;MyClass&quot; was destroyed. 七、替屬性和方法加上可視性 Assigning the Visibility of Properties and Methods加入可視性(Visibility)，可以決定能不能從物件外面控制物件的方法和屬性。 可視性有種：public、protected和private。 替屬性和方法加上可視性，是為了增加對物件的控制。For added control over objects, methods and properties are assigned visibility. Public Properties and Methods 當一個變數或方法的可視性(Visibility)被宣告為 public。這表示這些方法和屬性可以在類別的裡面與外面被存取。 到目前為止的範例中可視性都是宣告為 public。 Protected Properties and Methods 當一個變數或方法的可視性(Visibility)被宣告為 protected。該變數或方法只能在類別以及子類別的內部存取。 範例：把 MyClass 的 getProperty() 方法的可視性宣告為 protected，並且嘗試從外面呼叫這個方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass MyClass{public $prop1 = &quot;I'm a class property!&quot;;public function __construct(){ echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;';}public function __destruct(){ echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;';}public function __toString(){ echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty();}public function setProperty($newval){ $this-&gt;prop1 = $newval;}protected function getProperty(){ return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;;}}class MyOtherClass extends MyClass{public function __construct(){ parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;;}public function newMethod(){ echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;;}}// Create a objects$newobj = new MyOtherClass;// Use a method from the parent classecho $newobj-&gt;getProperty(); 執行這段程式碼之後，會出現以下 Call to protected method 錯誤： 123The class &quot;MyClass&quot; was initiated!A new constructor in MyOtherClass.Fatal error: Call to protected method MyClass::getProperty() from context '' in /Applications/MAMP/htdocs/CYOProject/ooptest/test.php line 55 接下來，在子類別 MyOtherClass 中新增一個 public 方法來調用 getProperty() ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } protected function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function callProtected() { return $this-&gt;getProperty(); }}// Create a objects$newobj = new MyOtherClass;// Call the protected method from within a public methodecho $newobj-&gt;callProtected(); 由結果可見，子類別可以調用父類別可性度為 protected 的方法: 1234The class &quot;MyClass&quot; was initiated!A new constructor in MyOtherClass.I'm a class property!The class &quot;MyClass&quot; was destroyed. Private Properties and Methods 當一個變數或方法的可視性(Visibility)被宣告為 private。該變數或方法只能在定義它們的類別內使用，如果有一個新的類別繼承了宣告有 private 屬性或方法的類別，新的類別以及所有的子類別將沒有辦法使用這些被宣告為 private 的屬性或方法。 範例：將 MyClass 的 getProperty() 方法的可視度宣告為 private，並且使用 MyOtherClass 的 callProtected() 方法來調用 getProperty()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } private function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function callProtected() { return $this-&gt;getProperty(); }}// Create a objects$newobj = new MyOtherClass;// Call the protected method from within a public methodecho $newobj-&gt;callProtected(); 重新載入瀏覽器，會因為 private 調用權限不足而得到錯誤訊息： 123The class &quot;MyClass&quot; was initiated!A new constructor in MyOtherClass.Fatal error: Call to private method MyClass::getProperty() from context 'MyOtherClass' in /Applications/MAMP/htdocs/CYOProject/ooptest/test.php line 49 靜態/非靜態成員當一個變數或方法被添加 static(靜態)，該變數或方法可以在類別還沒有被實例化就被調用。你可以透過範圍解析運算子(scope resolution operator) :: 來調用這些 static 屬性或方法。 範例：在 MyClass 加入一個 static 變數與方法： $count、plusOne()。在類別的外面使用 do…while 迴圈增加 $count 的值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass MyClass{ public $prop1 = &quot;I'm a class property!&quot;; public static $count = 0; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } private function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; } public static function plusOne() { return &quot;The count is &quot; . ++self::$count . &quot;.&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function callProtected() { return $this-&gt;getProperty(); }}do { // Call plusOne without instantiating MyClass echo MyClass::plusOne();} while (MyClass::$count &lt; 10); 小筆記 當使用範圍解析運算子存取 static 屬性時，記得要在屬性名稱前面加上錢字號 $ 輸出結果為： 12345678910The count is 1.The count is 2.The count is 3.The count is 4.The count is 5.The count is 6.The count is 7.The count is 8.The count is 9.The count is 10. 常數定義相對於變數而言，恆常不變的值而稱作常數。在 PHP 中使用 define() 宣告。而在類別中則是使用 const。常數只能是數值的值，包括布林、整數、浮點數和字串。若設為資源有可能會出現問題。常數和 static 類似，必須直接指定值，但不可運算。可直接透過範圍解析運算子(scope resolution operator) :: 來調用。 小筆記 常數調用時，直接使用定義名稱即可 範例: 於 MyClass 中定義一個常數 CLASS_NAME 並進行呼叫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpclass MyClass{ const CLASS_NAME = 'MyClass'; public $prop1 = &quot;I'm a class property!&quot;; public static $count = 0; public function __construct() { echo 'The class &quot;' . __CLASS__ . '&quot; was initiated!&lt;br /&gt;'; } public function __destruct() { echo 'The class &quot;' . __CLASS__ . '&quot; was destroyed.&lt;br /&gt;'; } public function __toString() { echo &quot;Using the toString method: &quot;; return $this-&gt;getProperty(); } public function setProperty($newval) { $this-&gt;prop1 = $newval; } private function getProperty() { return $this-&gt;prop1 . &quot;&lt;br /&gt;&quot;; } public static function plusOne() { return &quot;The count is &quot; . ++self::$count . &quot;.&lt;br /&gt;&quot;; }}class MyOtherClass extends MyClass{ public function __construct() { parent::__construct(); // Call the parent class's constructor echo &quot;A new constructor in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function newMethod() { echo &quot;From a new method in &quot; . __CLASS__ . &quot;.&lt;br /&gt;&quot;; } public function callProtected() { return $this-&gt;getProperty(); }}echo 'class name is ' . MyClass::CLASS_NAME; 得到結果: 1class name is MyClass 八、比較物件導向與直譯程式的差別兩種撰寫方式間沒有對和錯。只是如果使用物件導向來撰寫程式，在開發大型專案的時候會比較容易管理及維護。 因為物件可以將資料儲存在內部屬性內，因此物件內部的方法不必一直把屬性裝入參數內就可以運行了。再來，多個屬於同一個類別的物件可以同時存在。這在處理大量數據組合的時候可以把程式變得更加簡化。 雖然一開始可能令人生畏，但 OOP 確實提供了更簡單的方式來處理資料。“While it may be daunting at first, OOP actually provides an easier approach to dealing with data.” 如果實施正確的話，物件導向會明顯的降低你的工作量。“OOP will significantly reduce your workload if implemented properly.” 小叮嚀 不是每一件事情都需要被物件導向。一個簡單、範圍小的功能是不需要被包裝成一個類別的！撰寫功能時。你必須在物件導向與直譯程式之間好好做個選擇。 結語物件導向運用得正確會讓你的程式變易讀、易維護、易攜帶、可重複使用，這會減少你很多花額外的時間。","link":"/2019/05/04/PHP%20OO%20%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"},{"title":"設計模式 - 原型模式","text":"悟空只要拔毛一吹，就能複製出千千萬萬個自己。 設計模式是解決開發時遇到普遍存在(反覆出現)的問題的各種解法。但並不是絕對的，遇到問題才使用解法而不是為了使用而使用。 切記: 不要拿了錘子，看什麼都是釘子 介紹 屬於創建型設計模式，使你能夠復制已有對象， 而又無需使代碼依賴它們所屬的物件。 情境我們以頻果為例，基本上頻果都是相同的物件，但會因為產地不同而有不同的起始價格。而不同的時辰到貨，會有到貨日期上的差異。 範例先以抽象類別來製作頻果的原型。 12345678910111213141516171819202122232425262728293031abstract class ApplePrototype { /** * @var string */ protected $category; /** * @var int */ protected $price; /** * @var int */ protected $count; /** * @var string */ protected $time; abstract public function __clone(); /** * @return int */ public function details(): string { return $this-&gt;category . ' 單價: ' . $this-&gt;price . ' 數量: ' . $this-&gt;count . ' 到貨時間: ' . $this-&gt;time; }} 實作頻果 1234567891011121314151617181920212223/** * Class Turnips. */class Apples extends ApplePrototype{ /** * @var string */ protected $category = '頻果'; public function __construct(int $price, int $count) { $this-&gt;price = $price; $this-&gt;count = $count; $this-&gt;time = Date('Y-m-d'); } public function __clone() { # 故意將日期 + 1 天，做出時間區隔 $this-&gt;time = Date('Y-m-d' ,strtotime('+1 day')); }} 分批兩天到貨，頻果資訊僅到貨日期會有區別 12345678910# 初始化頻果 100 元 40 顆。$apple = new Apples(100, 40);# 頻果到貨echo $apple-&gt;details();echo '&lt;br /&gt;';# 第二天的蘋果到貨$apple2 = clone $apple;echo $apple2-&gt;details(); 結果 12頻果 單價: 100 數量: 40 到貨時間: 2022-04-30頻果 單價: 100 數量: 40 到貨時間: 2022-05-01 討論原型模式著重於物件可以被複製，被複製出來的物件只有局部的內容不相同，\b用最節省資源的方式，來處理重複性質高的物件。 優點 : 你可以克隆對象， 而無需與它們所屬的具體類相耦合。 你可以克隆預生成原型， 避免反復運行初始化代碼。 你可以更方便地生成復雜對象。 你可以用繼承以外的方式來處理復雜對象的不同配置。 缺點: 克隆包含循環引用的復雜對象可能會非常麻煩。","link":"/2022/04/30/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"程式設計","slug":"程式設計","link":"/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"GIT","slug":"GIT","link":"/tags/GIT/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Linux 基本指令","slug":"Linux-基本指令","link":"/tags/Linux-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"},{"name":"crontab","slug":"crontab","link":"/tags/crontab/"},{"name":"排程","slug":"排程","link":"/tags/%E6%8E%92%E7%A8%8B/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Schell Script","slug":"Schell-Script","link":"/tags/Schell-Script/"},{"name":"SOLID","slug":"SOLID","link":"/tags/SOLID/"},{"name":"設計模式","slug":"設計模式","link":"/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"資料加密","slug":"資料加密","link":"/tags/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86/"},{"name":"Aes","slug":"Aes","link":"/tags/Aes/"}],"categories":[{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"資料庫","slug":"資料庫","link":"/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"},{"name":"Schell Script","slug":"Schell-Script","link":"/categories/Schell-Script/"},{"name":"程式設計","slug":"程式設計","link":"/categories/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"設計模式","slug":"設計模式","link":"/categories/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"},{"name":"Aes","slug":"Aes","link":"/categories/Aes/"}]}