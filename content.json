{"pages":[],"posts":[{"title":"HTML JS 動態顯示 input file 選取內容","text":"使用 HTML 取得本地檔案1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; File API 可以從 File 物件中讀取 FileList ，FileList 內包含使用者所選取的檔案。如果使用者只選擇一個檔案，那麼我們只需要考慮第一個檔案物件。 使用 DOM 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = document.getElementById('testFile').files[0]; 使用 JQUERY 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; /&gt; JS: 1var file = $('#testFile').get(0).files[0]; 使用 change event 獲取選擇的檔案HTML: 1&lt;input type=&quot;file&quot; id=&quot;testFile&quot; onchange=&quot;selectFile(this.files)&quot; /&gt; JS: 123function selectFile(files) { var file = files[0];} 獲得選取的檔案資訊上述的例子顯示獲取在檔案清單裡所有檔案物件的方法。File 提供三個包含檔案重要訊息的屬性。 name: 唯讀的檔案名稱，並未包含檔案路徑。 size: 為 64 位元的整數，用以表示檔案的 byte 的長度。 type: 為唯讀字串。表示檔案的 MIME-type 。若是無法取得檔案的 Mime-type ，則其值會是一個空字串 “”。 使用 FileReader 讀取文件內容讀取文字HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectTextFile(this.files)&quot; /&gt;&lt;p id=&quot;showText&quot;&gt;&lt;/p&gt; JS: 12345678910111213function selectTextFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showText').src = this.result; }; reader.readAsText(file);} 當然也可以讀取圖片HTML: 12&lt;input type=&quot;file&quot; onchange=&quot;selectImgFile(this.files)&quot; /&gt;&lt;img id=&quot;showImg&quot;&gt;&lt;/img&gt; JS: 12345678910111213function selectImgFile(files) { if (!files.length) { return false; } let file = files[0]; let reader = new FileReader(); reader.onload = function () { document.getElementById('showImg').src = this.result; }; reader.readAsDataURL(file);} Code Demo","link":"/2020/08/17/HTML-JS-%E5%8B%95%E6%85%8B%E9%A1%AF%E7%A4%BA-input-file-%E9%81%B8%E5%8F%96%E5%85%A7%E5%AE%B9/"},{"title":"Hexo","text":"操作指令12# 開啟服務hexo server 12# 同步指令hexo d -g 細節待補","link":"/2019/11/29/Hexo/"},{"title":"Interface","text":"Interface 又稱 介面 接口 契約 介面本身是抽象的。指一系列的 Public 屬性或函式。所以你的物件，即便沒有實作任何介面他本身也是一個介面。它提供的介面就是自己所有 Public 的屬性跟函式。 介面可以確保依賴物件提供你想要的功能。 每個物件都是實作介面。 創造物件實作基礎介面，你的物件就可以執行語言的基礎函式 ex: foreach。 舉例: PHP 中的 array 也是實作幾個陣列功能會用到的 interface 還記得一個物件可以實作多個介面嗎？這裡會牽扯到兩個物件的耦合程度。假設你的函式宣告參數的型別是宣告成某個介面。那你在函式裡面只會拿到介面的 Public 屬性跟函式。但是如果你把參數的型別直接宣告成某個物件，在函式裡面就會拿到物件的所有 Public 屬性跟介面。 如果你的函式只需要其中一個介面提供的功能，那就在把參數的型別指定為介面就好。否則你會依賴整個物件。 結論你會發現整個語言都是照著介面在開發。所以有人常說 programin to a interface。介面只是定義一個抽象的概念，至於要實作成什麼樣子，是需要按照需求來決定。 重點是 interface 或抽象類別，都是向上層程式碼保證他們能提供指定的功能。 – 小知識: C＃ 跟 Java 一定會宣告參數的型別。這個叫做 Type hint，如果丟進去的參數不符合型別，編譯時就報錯。所以被叫做強型別語言。 PHP 跟 JS 沒有強迫一定要有 Type hint。稱作弱型別語言。","link":"/2019/11/26/Interface/"},{"title":"Mac建置自製Apache教學","text":"在 Mac 上建立自製 Apache 環境筆者心情小語…當你開心的遛個狗，哼哼小曲沒事想說更新一下心愛的 MAC 突然 Apache 開發環境就被 MAC OS 給狹持了(設定重置)!! 所以說 Apache 開發環境必須獨立! 特別感謝: 給力小夥伴指導我許多 LINUX 與 APACHE 相關設定及觀念。 為什麼要自製 Apache 環境MAC OS 更新版本有時都會突然的重置原生 Apache 設定。 特別是此次 OS 10.14，連 PHP 外部建置環境都給禁止了!! 若您是使用套件架設環境(MAMP、LAMP、XMAPP等…)，那您可能不會有太大的感悟。 但若是您用的是 MAC 提供的原生 Apache，那您可能連做個系統小更新都要小心翼翼的。 此處筆者用 HomeBrew 進行自製 Apache 環境建置。 需求 Mac OS(Linux) 系統電腦一台。 HomeBrew 開始建置吧 關閉 Mac OS 原生的 Apache 並防止他自行啟動 12345// 關閉 apache$ sudo apachectl stop// 禁止 apache httpd 自動啟動$ sudo launchctl unload /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/null 使用 HomeBrew 安裝 apache 1$ brew install httpd 通過指令檢查 apache 安裝，路徑應該被更改為 /usr/local/bin/apachectl 1$ which apachectl 確認啟用指令被改寫後，重啟 apache 1$ sudo apachectl -k start 設置預設啟用程序 1$ sudo brew services start httpd 設置 apache 基礎設定 brew 建置的 Apache 位置為: /usr/local/etc/httpd 編輯 httpd.conf 修改以下項目: Listen 80 ServerName localhost DocumentRoot &quot;/usr/local/var/www&quot; 開啟 rewrite_module (移掉 #): LoadModule rewrite_module lib/httpd/modules/mod_rewrite.so 至此， apache 應已建置完成並啟用。 連結網站吧！ 後話若您是剛開始進行網站架設，那後續 PHP 安裝可透過 brew 安裝。也可透過 Liip 進行後續環境建置。 請繼續往下走。 若您與筆者一樣是遭逢巨變而需要重新建置新環境。那後續設定僅需由 Mac Apache 那邊移植設定檔即可(注意設定檔不可直接使用，許多路徑都不同了)。 Liip 部分 筆者是自行移植載入檔案(/etc/apache2/other)，並於 httpd.conf 下自行添加 Include /usr/local/etc/httpd/other/*.conf。 HomeBrew 建置 PHP 環境待補 Liip 建置 PHP 環境待補 小知識: Mac OS 是使用 plist 文件設置程序隨機啟動。 plist 文件分佈在: /System/Library/LaunchDaemons/ 中，其中指令 apache 及 httpd 相關配置文件為 org.apache.httpd.plist。 使用 brew 不需 root 身份，若以 root 身份執行會被停止且警告。","link":"/2019/11/29/Mac%E5%BB%BA%E7%BD%AE%E8%87%AA%E8%A3%BDApache%E6%95%99%E5%AD%B8/"},{"title":"PHP Closure(閉包、匿名函式)","text":"還不知道 PHP 有 Closure? 那你真的落伍了！ What is Closure?Closure: 用於表示匿名函式的 Class。 閉包減少了命名空間的混亂。也讓使用對象之間減少了相依性。 PHP5.3 開始支援匿名函式，讓一些需要彈性的場合更方便。 建立匿名函式注意: 賦予變數匿名函示，結尾大括號需要加結尾符號 ;。 12345$wellcome = function () { echo 'Hi, wellcome to my Home ';};$wellcome(); 我們可以透過 use 的宣告語法賦予匿名函式變數。注意: PHP 7.1 起，不能傳入此類變數：superglobals、 $this 或者和參數重名。 123456$houseCategory = 'villa';$wellcome = function () use ($houseCategory) { echo 'Hi, wellcome to my ' . $houseCategory . '.';};$wellcome(); 讓我們添加函式的指定參數 123456$houseCategory = 'villa';$wellcome = function ($name) use ($houseCategory) { echo 'Hi ' . $name . ', wellcome to my ' . $houseCategory . '.';};$wellcome('YoYo'); 會使用了之後，我們馬上用遞迴特性寫一個從 1 加總到指定數字的閉包吧。 123456789$fib = function ($n) use (&amp;$fib) { if ($n == 0) { return 0; } return $n + $fib($n - 1);};echo $fib(10); 小分享筆者很常在 某段邏輯前後的行為 需要被重複使用時，使用閉包。例如 sql 的 Transaction。此處程式碼為 Demo 用，無法直接執行。 12345678910111213141516171819202122232425262728293031323334353637/** * sqlTransaction * * @param \\Closure $closure * * @return mixed * @throws Exception */public function sqlTransaction(\\Closure $closure){ $db = \\Zend_Db_Table::getDefaultAdapter(); try{ $db-&gt;beginTransaction(); $re = $closure(); $db-&gt;commit(); return $re; }catch (Exception $e){ $db-&gt;rollBack(); throw new Exception($e-&gt;getMessage()); }}public function saveData(){ $model = $this-&gt;_model; $this-&gt;sqlTransaction(function () use ($data, $model) { // TODO 邏輯檢查 $model-&gt;update(data); // TODO 更新後行為 });} 小知識 閉包可利用遞迴特性，取代 foreach 效果。 閉包可用於邏輯處理中段需要客製化邏輯時。 再叫現代化的 PHP 框架(如 Laravel)中，閉包已經是被大量使用的技術。 有興趣可自行去翻閱 Laravel 原始碼。 現在，你學會了嗎！？","link":"/2020/10/25/PHP-Closure-%E9%96%89%E5%8C%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E5%BC%8F/"},{"title":"PHP Traits","text":"What is Traits?PHP 僅支援單一繼承: 子類別只能繼承單一物件。 若是一個類需要繼承多種行為怎麼辦呢？ Traits 解決了這個問題。 Traits 就是解決在單線繼承的限制下，讓程式碼能夠重複使用。並降低複雜度。 Traits 用於聲明可以在多個 class 中使用的屬性(property)/函式(function)，可以是抽象或是任何可視性(public、protect 、private)，甚至是靜態(abstract)屬性。 如何使用建立語法 1234trait TraitName { // some code...} 使用語法 1234class newClass { use TraitName;} Example123456789101112131415trait message{ function msg() { echo 'Welcome to my home.'; }}class Welcome{ use message;}$welcome = new Welcome();$welcome-&gt;msg(); 可以同時使用多個 12345678910111213141516171819202122232425trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msgQuestion() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion;}$welcome = new Welcome();$welcome-&gt;msg();echo '&lt;br/&gt;';$welcome-&gt;msgQuestion(); 若是名稱重複了呢？函式名稱重複是會造成錯誤的。 Fatal error: Trait method msg has not been applied, because there are collisions with other trait methods on... 需要在使用時就指定要用哪一個的方法。insteadof: 宣告前者為主要使用，要是有多個要全部涵蓋進去哦。 123456789101112131415161718192021222324252627282930313233trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}trait messageC{ function msg() { echo 'C'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion, messageC; }}$welcome = new Welcome();$welcome-&gt;msg(); 那被替代掉的函式都不能用了嗎？as: 替方法進行別名。 1234567891011121314151617181920212223242526trait messageFriendly{ function msg() { echo 'Welcome to my home.'; }}trait messageQuestion{ function msg() { echo 'Why are you here?'; }}class Welcome{ use messageFriendly, messageQuestion { messageFriendly::msg insteadof messageQuestion; messageQuestion::msg as msgQuestion; }}$welcome = new Welcome();$welcome-&gt;msgQuestion(); 小提醒: 就算有使用 as 進行別名，還是需要先使用 insteadof 解重名哦。","link":"/2020/09/23/PHP-Traits/"},{"title":"Solid","text":"其實網路上對SOLID的探討及見解文章已經多不勝數。筆者在此僅記錄自身見解與歷程。 若對該原則理解有誤，請不吝指教。 SOLID? 在程式設計的領域中，SOLID指物件導向編成和物件導向設計的五個基本原則。 當這些原則一起被應用時，可以使程式設計師開發一個容易擴充及維護的系統。 SOLID所包含的原則是通過引發編程者進行軟體原始碼代碼重構的代碼異味清掃。從而使軟體清晰可讀及具可擴展性。 SOLID被典型的應用在測試驅動開發上，且是敏捷開發及自適應軟體開發的基本原則重要組成部分。 S: Single responsibility principle(SRP) 單一職責定義: 1一個類別(class)/方法(method)只能負責一個職責 如果一個類別做了兩件職責，就必須拆成兩個類別。 當類別包含複數職責時，則其內聚力越低。 當類別職責越單純且清楚，則其內聚力越高。 舉例: 如果汽車與飛機皆為交通工具而實作於同一個類別(super obj)中，汽車行為模式為 run 而飛機行為模式為 fly。那該類別內部邏輯會變得雜亂且難以維護。 若將汽車與飛機個別實作，各自物件只要管理自己的權責。即可提高內聚。而特定邏輯修改時只要到對應物件內做調整，也降低了維護的難易度。 結論: 一個 class/method 只做一件事。 遵守 SPR 可為程式提高內聚。 Open/close principle(OCP) 開放/封閉原則定義: 1程式在擴充新功能時，不更動原程式碼或者僅以最小幅度修改程式碼的開發方式。 系統實作完若遇到新需求，必須回頭調整原本做好的程式代碼。而只要修改舊的代碼就可能造成不良副作用 #1。應以最小的幅度來修改已存在的程式碼（甚至不修改)才是最佳的情況。 OCP 使系統保有彈性，可以擴充新功能。若有新需求只要進行新增，而不用修改到舊有程式碼(對修改封閉，對新增開放)。進而杜絕不良副作用的產生。 OCP 只是一個原則，讓程式變得靈活的代價是需要花費額外的時間與精力將程式引入新的抽象層，還會增加程式的複雜度。所以 OCP 原則只適合被套用於經常變更的地方！ (#1)不良副作用: 修改程式內碼造成其他使用的該邏輯的地方產生錯誤，即大家口中的改 A 壞 B。 舉例: 設計車子時，因單一職責(SPR)而對車上零件(車燈、輪胎、引擎)進行模組化。若此時若想將一般輪胎換成雪胎。而去修改一般輪胎的模組(物件)內容，可能造成其他使用該物件的邏輯錯誤。 若遵守 OCP 原則，僅對輪胎新增雪胎模組，在車子內部進行替換組合。則只需新增還不需要修改。拒絕了改 A 壞 B的情況產生。 結論: 只有經常變更的地方需要使用 OCP 原則。 系統對新增開放，修改封閉。 L: Liskov substitution principle(LSP) Liskov替換定義: 12Subtypes must be substitutable for their base types.所有子類別都可以代理父類別的工作。 里氏替換原則原則要能夠成立，介面(interface)/抽象方法(Abstract method) 就必須要遵守定義去實做。 子類別需兌現對父類別的承諾，遵照父類別設計開發。 作為子類別的方法必須和他們父類別的方法操作一致，子類別中可以擁有父類別沒有的特殊功能，但是繼承的方法，功能應該兩者一致的。 子類不只是實現父類別的方法，而且必須名符其實，否則會發生無法預料的事情。 舉例: 雪胎及一般輪胎皆繼承輪胎模組(父類別)，而組裝者可由方法取得材質(function)取得輪胎材質來判斷是否適合組裝。若雪胎擅自更改回傳值為適用地形。就會造成組裝者誤判而產生無法逾期之錯誤。 若遵守 LSP 原則，取得材質(function)方法應該遵循輪胎模組(父類別)設計結構去回傳正確值。即可避免程式的行為變得不可預測。 結論: 子類別必須遵從父類別或介面的設計理念去實作方法。 LSP 是實現 OCP 原則的重要方式，只有當子類別能夠完全替代它們的父類別類時，使用父類別的函數才能夠被安全的重用。 I: Interface Segregation Principle(ISP) 介面隔離定義: 12Clients should not be forced to depend upon interfaces that they don’t use.介面不應該強迫 Client 依賴於它們用不到的方法。 12The dependency of one class to another one should depend on the smallest possible interface.類別之間的相依關係應該建立在最小的介面上 類別與類別之間的關係，應只依賴彼此需要的最少介面，介面不能太肥，應該要細化。 介面的目的都是提供一個讓 Client 端可以使用我們開發模組的管道。 介面處於應用程式與模組之間、或是專案與模組之間，這種關係就如同第三方套件提供服務 API 給一個網站使用。 舉例: 跑車與玩具車皆繼承汽車模組(父類別)，而汽車模組(父類別)存在一方法跑(function)。但玩具車並不具備跑(function)這個行為，若是空實作則違反 LSP 原則。 應該設計兩介面(interface):模型車(interfece)與實車(interface)。而於實車(interface)內部宣告跑(function)方法，再由跑車與玩具車個別去實作對應的介面(interface)。 結論: ISP 可降低商業邏輯（低階模組）與 Client 之間的耦合。 設計模組時，要以 Client 需求的角度建立介面，且避免設計龐多功能的單一介面。 設計介面(interface)的時候，應該考慮單一職責原則，把有關聯的方法放在一起，分割出多個單一功能的介面。 D: Dependency Inversion Principle(DIP) 依賴反轉定義: 12High-level modules should not depend on low-level modules. Both should depend on abstractions.高階模組不應該依賴於低階模組，兩者都該依賴抽象。 12Abstractions should not depend on details.抽象不應該依賴細節。 12Details should depend on abstractions.低階模組的實作內容應該依照抽象的定義去實作。 高階與低階，是相對關係，其實也就是 呼叫者 (Caller) 與 **被呼叫者 (Callee)**。 ￼高階模組直接依賴低階模組，則為高耦合。 不應該讓任何東西直接依賴低階模組。 DIP 由 DI(注入) 與 IOC(控制反轉) 實作。目的為解除耦合性(解偶)。 舉例: 實作汽車時需組裝零件，此時若將零件寫死於汽車中。若其中一項零件停產了或要更換。則需到汽車中修改既有內碼(違反 OCP)。 以輪胎為例，汽車有內碼使用 一般輪胎。而一般輪胎剛好停產或廢棄了。那汽車即會出錯。若是要修改還需要到汽車內碼中將使用 一般輪胎改成使用 新的一般輪胎。 若依照 DIP 設計。將輪胎抽離於組裝者取得並組裝於車上。舉例來說汽車-&gt;組裝輪胎(一般輪胎)。依上述情境若一般輪胎出事了，組裝者只要從外部替換輪胎汽車-&gt;組裝輪胎(新的一般輪胎)。則不用更動汽車程式內碼，汽車與輪胎之間也不具備耦合性。 結論: 介面(interface)應由高階模組去制定規範。 使用介面(interface)確保低階模組開發正確性。 遵守 DIP 可大大降低物件之間的耦合性(解偶)。 依賴反轉原則可以幫助我們遵守其他原則，遵守依賴反轉的過程中會： 拆散類別的職責(SRP)。 更容易達成 OCP。 避免父子類別沒有依照介面的定義實作(LSP)。 拆散介面的職責(ISP)。 ——————-工程師最怕聽到的就是程式又要改。而SOLID原則是前人經過無數經驗統整出使程式具備容易維護且具可擴充性質。讓之後在更動程式或擴充需求時能降低修改既有程式難易度。雖說SOLID原則能使程式品質有實質的躍升，但還是得注意別陷入過度設計。 參考網址物件導向程式設計基本原則 - SOLID 【筆記】物件導向設計 : SOLID 介紹","link":"/2019/11/26/Solid/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/30/hello-world/"},{"title":"PHP 資訊安全 - 資料消毒","text":"荀子-性惡篇第二十三: 人之性惡，其善者僞也。 永遠不要相信任何來源不明的資料 不可信資料來源只要不是系統產出組合之資料，皆不可信。 如下: 12345678910$_GET$_POST$_REQUEST$_COOKIE$argvphp://stdinfile_get_contents()遠端資料庫遠端 API來自客戶端的資料 只要是外部來源資料都有可能是攻擊的源頭(XSS、CSRF等…) 怎麼說呢？您的網站允許使用 HTML 下評論，那將有可能受到 &lt;script&gt; 隱碼攻擊。 12345&lt;p&gt;This is good!!!&lt;/p&gt;&lt;script&gt;window.location.href='https://hank7891.github.io/';&lt;/script&gt; 您的登入帳號密碼被如此輸入，即會遭受 SQL Injection。 1234567891011account: ' OR 1=1 #password: 1234$account = $_GET['account']; // '' OR 1=1 #$password = $_GET['password'];$query = &quot;SELECT * FROM user WHERE account = '$account' AND password = '$password'&quot;;產生指令: SELECT * FROM user WHERE account = '' OR 1=1 #AND password = '1234'; 如此一來是不是令您毛骨悚然呢？ 所以呢？想要開發安全的 Web 應用程式，最重要的是正確掌握資料的用途狀態。 一般正規化消毒→一般處理用資料 例如：trim、magicquotesgpc、NUL、強制轉型、大小寫轉換、值域範圍檢查、白名單檢查、RegExp規則檢查 HTML輸出用消毒→HTML輸出用資料 例如：htmlspecialchars, strip_tags, htmlentities SQL輸出用消毒→SQL輸出用資料 例如：mysqlrealescape_string, addslashes – 最重要的是，這些用途的資料，應明確加以區別，不要混淆使用，一定要明確配合用途進行轉換。 所有資料的交換，都應使用一般處理用資料來進行，再依資料用途進行消毒，避免混用而造成遺忘或重複消毒。","link":"/2020/11/27/PHP-%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8-%E8%B3%87%E6%96%99%E6%B6%88%E6%AF%92/"},{"title":"重新擁抱程式設計 - 淺談 JavaScript","text":"世界上最流行的程式語言之一又號稱世界上被誤解最深的程式語言。 世界上最被人誤解的程式語言 - JavaScriptJavaScript 又名 Mocha、LiveScript、JScript 又或者叫 ECMAScript。 原因如下: The Name 許多人會將 JavaScript 當成是 Java 的子程式、也因為 script 這個字眼，而認為它不是一個真正的程式語言。 Moving Target 初版的 JS 非常的粗糙，沒有例外處理、內部函式、以及繼承的概念。即便現在的版本已經是一個物件導向的程式語言，但初期的壞印象仍讓許多人有既定的印象。 Design Errors JS 與其他語言一樣，有許多設計上的錯誤，例如 + 號同時代表了字串的串接及數值的相加、或者是 with 的使用、Regular Expression 的寫法、保留字的使用太過嚴格，這些設計上的錯誤都讓人在開發過程中產生疑惑。 令人驚訝的是，ECMA 組織似乎沒有要修正這些問題。 Bad Implementations 較早期的錯誤撰寫方式存在許多嚴重的錯誤。更糟糕的是，這些實現被嵌入到令人毛骨悚然的錯誤 Web 瀏覽器中。 Amateurs 通常編寫 Javascript 都是不具有程式語言背景的工程師，寫出來的東西自然就給人奇差無比的觀感。 Bad Books 書籍及文件所提供的錯誤觀念。 Substandard Standard 不夠標準的規範，ECMA 所發布的規格質量極差。這很難閱讀，也很難理解。這是造成 Bad Book 問題的原因，因為作者無法使用標准文檔來提高自己對這種語言的理解。 JavaScript 的名字由來最開始這門語言取名叫「Mocha」，1995 年 9 月 Netscape 宣布要在LiveWire (伺服器端環境) 啟用某個程式語言，於是這門程式語言就被叫做「LiveScript」。 同年 12 月基於行銷考量，為了讓這門語言搭上 Java 這個程式語言「熱詞」，因此將其臨時改名為 JavaScript，日後這成為大眾對這門語言有諸多誤解的原因之一。 所以，Java 跟 JavaScript 到底有沒有關係？除了名字之外，根本沒有關係。之所以名字會很像，只是單純 Netscape 想要蹭熱度罷了。 JavaScript 基礎篇[1]: 變數與資料型別&gt;&gt;&gt;","link":"/2020/12/01/%E9%87%8D%E6%96%B0%E6%93%81%E6%8A%B1%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%20-%20%E6%B7%BA%E8%AB%87%20JavaScript/"},{"title":"JavaScript基礎篇[1] 變數與資料型別","text":"JavaScript 基礎 – 變數與資料型別。 變數可以將變數想像為一個盒子，是用來存放資料的。 在 JavaScript 中的變數宣告是有規則的，開頭必須是英文字母、底線(_)或錢字號($)，後面可以接著英文字母、底線(_)或錢字號($)以及數字。變數名稱不可以是保留字(Reserved Words) 與關鍵字(keyword)。 JavaScript 是有區分大小寫的，變數 apple 與 Apple 將會被視為不同的兩個變數。且 1.3 版之後支援 Unicode。代表著你可以用中文來當變數名稱。 但還是避免使用非英文字母來做變數名稱命名，用中文編碼的話，其他語系系統開啟可能會造成亂碼的情況。 變數在使用前，可以透過 var 來進行宣告的動作。在 ES6 之後多了 let 與 const 兩種。由於 JavaScript 是個 弱型別[註1] 的語言，變數本身無需宣告型別，型別的資訊只在值或物件本身。 12345// 透過 var 宣告變數 apple 但沒賦予其值，此時 apple 的內容為 undefined。var apple;// 透過 var 宣告變數 apple 且賦予其值，此時 apple 的內容為 'apple'。var apple = 'apple'; 若沒宣告變數就要使用的情況下，會出現 ReferenceError。 如下: 1console.log(hello); 或許你會發現，即便沒有用 var 進行變數宣告，仍可以定義變數並給予值。但強烈不建議這麼做。因為，沒有使用 var 宣告的變數，全都會變成全域變數。 全域變數 後續再做解說。 12apple = 'apple';console.log(apple); // 沒錯，就是 'apple'。 註1: 程式語言中，是有型別系統(type system)的。區分為型別、弱型別。強型別語言在定義變數時就必須給予變數指定型別，若這個變數做了錯誤型別運算，則會出現錯誤。弱型別語言則相反，雖然多了許多方便性，但要注意型別轉換時可能產生的非預期錯誤。 資料型別 變數沒有型別，值才有。 由於 JavaScript 是個弱型別的程式語言，嚴格來說，變數本身其實不帶有資料型別的資訊，其中的值或物件才有。 JavaScript 的型別主要可分為原始型別(Primitives)與物件型別(Object)。 原始型別包含了 string、number、boolean、null、undefined。而在 ES6 中多了 Symbol。 12345typeof true; // 'boolean'typeof 'apple'; // 'string'typeof 123; // 'number'typeof { }; // 'object'typeof [ ]; // 'object' string 字串字串需用單引號 ' '或雙引號 &quot; &quot;包住，兩者不可混用，意思是誰開頭就要誰結尾。 單引號與雙引號的使用在 JavaScript 沒有什麼差異，依習慣使用即可。 12var str = '我是字串';var str2 = &quot;我也是字串&quot;; 若引號不成雙對的話會出狀況，如: 12var str = 'Let's go!'; // Errorvar str = &quot;Let's go!&quot;; // OK 如果真的非用單引號不可，則可用 \\(跳脫字元 escape character)處理: 1var str = 'Let\\'s go!'; // OK 組合字串用 +: 1var str = 'Hello, ' + 'word.'; 字串太長需換行銜接可用 \\: 123var str = '這是第一行 \\這是第二行 \\這是第三行'; 注意: \\ 後面不能有東西呦，包含空白。 number 數字JavaScript 僅有的一種數值的型別，不管整數或小數點都是。 12var num = 1;var num = 1.2; 特殊的數字 Infinity (無限大)、-Infinity (負無限大)，以及 NaN。備註: NaN 不是數值。 正數除以 0 會得到 Infinity (無限大)，負數除以 0 會得到 -Infinity (負無限大)。 12var num = 1 / 0; // Infinityvar num = -1 / 0; // -Infinity 那 0/0 呢？ 結果是 NaN。甚至是 Infinity / Infinity 或 -Infinity / -Infinity 也會都得到 NaN。NaN 是個有趣的存在，字面上的意思是 Not a Number。但用 typeof 來判斷，他又告訴你它是 number。 1console.log(typeof NaN); // number NaN 無法做任何數字的運算，結果都會是 NaN。也就是說 NaN 不屬於任何數字，甚至是自己。 1NaN === NaN; // false 所以我們需要 isNaN 函示來檢查它: 1234isNaN(NaN); // trueisNaN(123); // falseisNaN(&quot;123&quot;); // false, 因為字串 &quot;123&quot; 可以透過隱含的 Number() 轉型成數字isNaN(&quot;NaN&quot;); // true, 因為字串 &quot;NaN&quot; 無法轉成數字 順帶一提，JavaScript 的 number 也是基於 IEEE 754 來實作。所以當你執行 0.1 + 0.2 == 0.3 時。 為什麼呢！？這是因為… 自己看 Why 0.1 + 0.2 !== 0.3 不僅是 JavaScript 會產生這種問題，只要是採用 IEEE 754 的浮點數編碼方式來表示浮點數時，全都會產生這類問題。 boolean 布林值 JavaScript 中，所有的東西都可以轉換為 boolean。 boolean 就簡單多了，其值只有兩種: true、false。是由發明的科學家 George Boole 命名。 123var a = true;var b = false;var c = (2 &gt; 1); // true null &amp; undefined若使用 Boolean() 將 null 與 undefined 轉換為布林值，結果都會是 false。但兩者間仍有意義上的差別，故將它們放在一起講。 兩者的共通點是都只有一種值，null 僅有 null，undefined 僅有 undefined。 12var a; // undefined, 宣告卻未給值。var b = null; // null, 明確給予變數 null。 undefined 代表的是**(此變數) 還沒有給值，所以不知道是什麼**。 null 代表的是此變數可能曾經有值)，但現在沒有值。 也可以使用 Number() 強制轉換為數字來看出什麼。 12Number( null ); // 0Number( undefined ); // NaN 還有一點有趣的事，在非全域作用範圍下 undefined 允許被當成是變數使用。 12345(function() { var undefined = 'apple'; console.log(undefined); // apple console.log(typeof undefined); // string})() 甚至是被當成參數來用: 1234(function(undefined) { console.log(undefined); // apple console.log(typeof undefined); // string})('apple') 我看還是別這樣惡搞你的程式了吧。搞同事的就好！ 基礎篇[2]: —&gt;&gt;&gt;","link":"/2020/12/06/JavaScript-%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5/"},{"title":"正規表示式 - Regular Expression","text":"正規表示式 (Regular Expression)能為你檢查是否為全英文字串！ 很專業！ 正規表示式 (Regular Expression)能為你檢查是否為指定結構字串！ 很貼心！ 正規表示式 (Regular Expression)能為你找出複雜性組成字串！ 很厲害！ What is it?Regular Expression 又稱正規表達式、正規表示法、規則運算式、常規表示法。是一門電腦科學，是用來比對字串是不是有符合正確的格式。 語法簡單，功能強大，最重要的是！幾乎已知的語言都有支援他。包誇了各大編譯器皆有支援。 開始之前讓我們擁有一個實用的線上工具 regex101。 您可以在 TEST STRING 的地方輸入 focus，在於 REGULAR EXPRESS 的地方輸入 focus 或其中一字元都行(注意大小寫)。是否被選起來了呢！ 下面的教學皆可直接扔進線上工具內使用哦！ 注意: 正規表示法使用時前後須由 / 包起來(/a/)，但該工具 REGULAR EXPRESS 中輸入時不用。 語法字元 12a: a字元.: 所有可能的字元(字母、數字或符號)。 RegExp 說明 範例 /a/ 含有字元 a a , ab , ba , bbacc /./ 任意單一字元 a , ab , ba , bbccc , 哈囉 /a./ 含有字元 a 且後面接任意單一字元 a1 , ab , a囉 次數 12345678*: 比對前一個字串 0 次或是多次。?: 比對前一個字串或是不比對。+: + 跟 * 類似，差別在於它至少要與前一個字比對一次或以上。{n,m}: 指定出現次數，n 為最小次數 m 為最大次數。{2}: 2 次。{2,}: 2 次以上。{2,5}: 2 到 5 次。 RegExp 說明 範例 /ba*c/ bc 字元中間，a 字元出現 0 次或是多次。 bc , bac , baaac /ba?c/ bc 字元中間，a 字元出現 0 次或一次。 bc , bac /ba+c/ bc 字元中間，a 字元出現 0 次或一次。 bac , baaac /ba{2}c/ bc 字元中間，a 字元出現 2 次。 baac /ba{2,}c/ bc 字元中間，a 字元出現 2 次以上。 baac , baaac /ba{2,5}c/ bc 字元中間，a 字元出現 2 - 5 次。 baac , baaaaac 條件 1234^: 字串開頭。$: 字串結尾。|: 前字串或者後字串。\\: 跳脫特殊字元。 若要比對正規表示式內部特殊字元(*?+{}[] 等...)，需用反斜線來跳脫這些特殊字元。 RegExp 說明 範例 /^ab/ ab 開頭字串。 ab , abc /ab$/ ab 結尾字串。 ab , cab /acc bcc/ acc 字串或 bcc 字串。 /a\\*/ a*字串。 a* , aa* , a*a 多字元篩選 123[ ] : [] 內所包含字元。[^] : 不存在 [] 內的任何字元。[-] : 連號字元(0-9 a-z A-Z)。 RegExp 說明 範例 /[abc]/ abc 任一字串。 abc , ade , bde , cde /[^abc]/ 非 abc 任一字串。 def , ggg , ddd /[0-9]/ 數字 0 - 9 0123456789 , a0b , 9a8n 在 [ ] 後面接上 {n}，則會取得 [] 中指定數量組合(不分順序)。 1EX: [abc]{2} : `ab` , `cb` , 'ac' 特殊字元 123456\\d: 任何數字字元，等同 [0-9]\\D: 任何非數字字元，等同 [^0-9]\\w: 任何數字字母底線，等同 [A-Za-z0-9_]\\W: 任何非數字字母底線，等同 [^A-Za-z0-9_]\\s: 任何空白字元(空白,換行,tab)，等同 [ \\f\\n\\r\\t\\v]\\S: 任何非空白字元(空白,換行,tab)，等同 [^ \\f\\n\\r\\t\\v] 實例12345678西元生日: 四個數字開頭 - 兩個數字 - 兩個數字結尾RegExp: /^\\d{4}-\\d{2}-\\d{2}$/身分證字號: 英文字母開頭(大寫) 九個數字RegExp: /^[A-Z]\\d{9}$/手機號碼: 國碼開頭(09) 八個數字RegExp: /^09\\d{8}$/ 同場加映Regex matching line not containing the string不包含指定的字元！ 1RegExp: ^((?!YoYo).)*$ Hello YoYo! Hello Hank! 保留差異字元取代 筆者覺得這個超重要，大家一定要會。 在正規表示式中被 () 所選起來的參數可以被保留至變數中。保留變數會由 $1 $2 $3 所使用。 12345678910# 一段句子中，若只替換問候語而保留人名。Hello, YoYo!Hello, Hank!搜尋 RegExp: /Hello, (.*)!/取代 RegExp: /Shit, $1!/# 輸出結果Shit, YoYo!Shit, Hank! 什麼？ 你問我這有什麼用？筆者遇到的問題是，因為語言版本的關係。要將程式內的變數使用 {} 替換為 []; 12345678Ex:$str{0};$str{1};$str{2};$str{3};$str{'name'};$str{'email'}; 總不可能要我一個一個去替換吧！！這邊考考各位，要怎麼一組替代語法將 $str{} 替換成 $str[] ！筆者的答案在下方哦 ※1。 結語Regular Expression 是非常好用的工具，且應用範圍很廣。編譯器對專案全區域搜尋、各程式語言內部使用設置是資料庫應用都可以做出很好的工作效率。 這篇只是筆者對基本 Regular Expression 的介紹。大家能在利用網路資源，進行更深入的學習。 ※1: 12搜尋 RegExp: \\$str\\{([^\\}]*)\\}取代 RegExp: \\$str\\[$1\\]","link":"/2021/02/23/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F%20(Regular%20Expression)/"},{"title":"PHP 輸出 Log 檔案","text":"用於輸出指定 PHP 檔案資訊。 廢話不多說，直接 Demo123456789101112131415161718192021222324//設定路徑目錄資訊$years = date('Y-m');$url = './log/' . $years . '/log.txt';//取出目錄路徑中目錄(不包括後面的檔案)$dir_name = dirname($url);//如果目錄不存在就建立if(!file_exists($dir_name)) { mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $dir_name), 0777, true);}// 寫入資訊$msg = date('Y-m-d H:i:s');//開啟檔案資源通道，不存在則自動建立$fp = fopen($url,&quot;a&quot;);//寫入檔案fwrite($fp,var_export($msg,true).&quot;\\r\\n&quot;);//關閉資源通道fclose($fp);","link":"/2021/03/03/PHP%E8%BC%B8%E5%87%BALog%E6%AA%94%E6%A1%88/"},{"title":"Linux 排程設定(crontab)","text":"linux 排程設定。 linux crontab 設定。 linux 自動工作設定 crontab 設定。 夠了哦！！… 查看與編輯查看自己 crontab 1crontab -l 查看指定使用者的 crontab 1sudo crontab -u username -l 編輯自己的 crontab 1crontab -e 編輯指定使用者的 crontab 1sudo crontab -u username -e 刪除所有 crontab – 注意: 是所有!!! 1crontab -r 設定在 crontab 設定中，每一行設定就代表一個定期排程。 基本設定格式如下: 1MIN HOUR DOM MON DOW CMD 欄位 說明 解說 MIN 分鐘 0 - 59。 HOUR 小時 0 - 23。 DOM 日 1 - 31。 MON 月 1 - 12，可用英文縮寫 Ex: Jan。 DOW 星期 0 - 7，0 與 7 的是星期日。也可用英文縮寫 Ex: Sun。 CMD 執行指令 任何可執行的程式或指令稿。 特殊符號 字元 說明 *(星號) 代表接受任意時刻。 若在月份那一欄填入星號，則代表每一月份皆會執行指令。 ,(逗號) 代表分隔時段。 如果要下達的工作是 3:00 與 6:00 時，就會是： 0 3,6 * * * CMD -(減號) 代表一段時間範圍內。 8 點到 12 點之間的每小時的 20 分都進行一項工作：20 8-12 * * * CMD /n(斜線) n 代表數字，亦即是『每隔 n 單位間隔』的意思，例如每五分鐘進行一次，則：*/5 * * * * CMD 開始設定由於需要設定的內容很多又不方便記憶，所以可以將下列註解貼在開頭。 1234567# ┌───────────── 分鐘 (0 - 59)# │ ┌─────────── 小時 (0 - 23)# │ │ ┌───────── 日 (1 - 31)# │ │ │ ┌─────── 月 (1 - 12)# │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日)# │ │ │ │ │# * * * * * command 以下是一些基本的範例，指令為寫入觸發時間。 注意: 確認執行路徑是否可行，可先將 cmd 指令拿去執行看是否可行。 12# 輸出觸發時間至指定位置date &gt;&gt; ~/text.txt 12345678# 每五分鐘執行一次*/5 * * * * date &gt;&gt; ~/text.txt# 每日早上 8 點到 12 點，整點執行0 8-12 * * * date &gt;&gt; ~/text.txt# 每月 1 日 、15 日、29 日 凌晨五點各執行一次0 5 1,15,29 * * date &gt;&gt; ~/text.txt 設定好後儲存，即可生效！ 實用工具 Crontab Guru，能夠幫你轉換為人類可讀時間。","link":"/2021/03/12/Linux%20%E6%8E%92%E7%A8%8B%E8%A8%AD%E5%AE%9A(crontab)/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"程式設計","slug":"程式設計","link":"/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"SOLID","slug":"SOLID","link":"/tags/SOLID/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"crontab","slug":"crontab","link":"/tags/crontab/"},{"name":"排程","slug":"排程","link":"/tags/%E6%8E%92%E7%A8%8B/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"程式設計","slug":"程式設計","link":"/categories/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"}]}